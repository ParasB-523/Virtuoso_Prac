;////////////////////////////////////////////////////////////////////// 
;//                                                                  //
;//     Title     : 0.18um Mixed Mode Technology 1.8V/3.3V 1P6M	     //
;//		    Process Topological Layout Rule (With Metal/     //
;//		    Metal Capacitor Module)		             //
;//     Parent Doc: G-03-MIXEDMODE/RFCMOS18-1.8V/3.3V-1P6M-MMC-TLR   //
;//	Revision  : 2.5		                                     //
;//                                                                  //
;//     LIMITATION OF LIABILITY:                                     //
;//        United Microelectronics Corp. is not  liable  for  any    //
;//        property damage, personal  injury,  loss  of  profits,    //
;//        interruption of business,  or  for  any other special,    //
;//        consequential or incidental  damages, however  caused,    //
;//        whether for breach of warranty,contract tort(including    //
;//        negligence),strict liability or otherwise.                //
;//                                                                  //
;//	assura version av3.1.3:Production:dfII4.4.6                  //
;//								     //
;//////////////////////////////////////////////////////////////////////
;//revision    date       who               changes                  //
;//======== ========== ========= =================================== //
;// 1.2-p1  05/06/2002 Kevin Tso  Create from G-03-MIXEDMODE/        //
;// 			          RFCMOS18-1.8V/3.3V-1P6M-MMC-TLR    //
;//				  Ver:1.2			     //
;// 2.1-p1  06/10/2002 Kevin Tso  Modify based on TLR revision to    //
;//				  v2.1-p1			     //
;// 2.1-p2  06/21/2002 Kevin Tso  Solve 4.18M false violation problem//
;//				  and redefine sab poly              //
;// 2.1-p3  09/11/2002 Kevin Tso  Solve 4.31H false violation problem//
;// 2.2-p1  12/13/2002 Kevin Tso  Add 4.29G                          //
;//                               Modify 4.29H  P-Well block layer   //
;//                               -> MCAP (block P-Well implant)     //
;//                               Modify 4.31H  P-Well block layer   //
;//                               -> IND                             //
;// 2.2-p2  01/02/2003 Kevin Tso  Correct DFII layer naming          //
;// 2.2-p3  03/07/2003 Kevin Tso  Make Cadence DFII layer definition //
;//                               consist to technology file and add //
;//                               DIOBLK layer to filter false error //
;//                               4.16N and 4.17N                    //
;// 2.2-p4  03/31/2003 S M Lee    Update the "Max metal space" rules //
;// 2.2-p5  04/11/2003 S M Lee    Update the "Max metal space" rules //
;// 2.2-p6  04/22/2003 S M Lee    Add BLSPLP memory cell             //
;// 2.2-p7  09/09/2003 S M Lee	  To unify Assura and Diva coding,   //
;//				  and revise some coding errors.     //
;// 2.2-p8  12/29/2003 S M Lee	  Update the 4.14D.b1/b2 rules       //
;// 2.3-p1  12/29/2003 S M Lee    According the TLR version 2.3      //
;// 2.3-p2  02/19/2004 S M Lee    Update the 4.15O rule              //
;// 2.3-p3  04/06/2004 S M Lee    Update the 4.15O rule              //
;//				  Change the "resdummy" to "NWR"     //
;// 2.4-p1  10/12/2004 S M Lee    Modify based on TLR version 2.4    //
;// 2.5-p1  01/06/2005 S M Lee    Modify based on TLR version 2.5    //
;//////////////////////////////////////////////////////////////////////
;// Notice (Important, Read Me First)
;// =================================
;// (1) Reference Document:
;//		    G-03-MIXEDMODE/RFCMOS18-1.8V/3.3V-1P6M-MMC-TLR   
;//       	      "0.18um Mixed Mode/RFCMOS Technology 1.8V/3.3V 
;//		      1P6M Process Topological Layout Rule	     
;//	  	      (With Metal/Metal Capacitor Module)"	     
;//       	      - Rev. 2.5				     
;//     	    G-1B-014					     
;//       	      "Bonding Pad Layout Guidelines"  (Ver. 6_P1)   
;//     	    G-1B-029					     
;//       	      "0.18um ESD Design Rules"  (Ver. 8_P1)	     
;//
;// (2) The layer definition in this rule file is based on UMC Official
;//	Layer Mapping Table. If your layer definition is inconsistent
;//	with UMC Official Layer Mapping Table, please modify the
;//	layer definition in layerDefs() according to your database.
;//
;// (3) Please check the notes written in the command file showing 
;//	which rules are not implemented.
;//
;// (4) This rule file has implemented those memory rules.
;//
;// (5) Switches are used for implementing various run options.  The
;//     switches are defined as follows in the control (.rsf) file:
;//
;//         avParameters(
;//                     ...
;//                     ...
;//                     ?set "switch_name1" 
;//                     ?set "switch_name2" 
;//                     ?set "switch_name3" 
;//                     ...
;//                     ...
;//                     ) ; end avParameters
;//
;//     Note that multiple switches are allowed.
;//
;//     The following switches are present in this file:
;//
;//     Technology Switches
;//       - "metal2_is_top"         Specifies 2-Metal Technology
;//       - "metal3_is_top"         Specifies 3-Metal Technology
;//       - "metal4_is_top"         Specifies 4-Metal Technology
;//       - "metal5_is_top"         Specifies 5-Metal Technology
;//     Chip-Level Switches
;//       - "SR"                    Seal ring rules are checked
;//	  - "Die_Corner_Rules"	    Die Corner check for Metal		
;//     Run-Time Intensive Switches
;//       - "check_max_metal_space" Maximum metal spacing check
;//       - "check_density"         Metal coverage rules are checked
;//       - "check_slots"           Slot rules are checked
;//
;//     By default, if none of the switches are set, the file will
;//     assume the following:
;//       - The design incorporates 6-metal technology
;//       - The chip-level checks will NOT be performed
;//       - The run-time intensive checks will NOT be performed.
;//
;//     WARNING:  If multiple "metalX_is_top" switches are set, there is
;//               no way of knowing how the check will be performed.
;//
;// (6) This file produces a number of "info" messages during the run.
;//     These messages should be ignored.
;//
;// (7) SkewEdge drawing in inductor might casue false error for 4.31A/4.31B.
;//     This will be improved in future revision.
;//
;// Assumptions:
;//
;// 1)  Resistor Identification Layers - The following layer definitions
;//     are assumed:
;//     - NWR (Layer 40) - Custom resistor ID layer (for use with
;//       Cadence PDK).
;//     - rsymbol (Layer 81) - Diffusion resistor ID - not used for DRC
;//     - psymbol (Layer 82) - Poly resistor ID - not used for DRC
;//     - wsymbol (Layer 83) - Well resistor ID
;//     Within this rule file, the NWR and wsymbol layers are ORed
;//     so either can be used to define a well resistor.
;// 
;// 2)  Undefined Layers - The following layers are assumed to be
;//     generated and are therefore not defined:
;//     - PWELL Layer (Section 4.6 in the TLR document)
;//     - Vtn Layer (Section 4.10 in the TLR document)
;//     - P-Layer (Section 4.11 in the TLR document)
;//     - N-Layer (Section 4.12 in the TLR document)
;// 
;// 3)  45/90-Degree Checks
;//     Checks for non-45-degree or non-90-degree edges are not
;//     included in this file because nothing the design rule document
;//     does not restrict polygon edges in this manner.  If this check
;//     needs to be added, the rsf file can be altered to check all
;//     polygons for non-45 or non-90.
;//
;// 4)  Off-Grid Checks
;//     Off-Grid checks are not implemented in this rule file because
;//     there is not specification in the design rule document
;//     indicating the grid size.  If this check needs to be added, the
;//     rsf file can be altered to check all polygons against a grid
;//     value.
;//
;// 5)  N-Well Equal vs. Non-Equal Potentials
;//     The definition of Wells being at equal potentials was assumed to
;//     be based on electrical connectivity - if multiple wells are
;//     electrically connected, those wells are considered to be at
;//     equal potentials.
;//
;// 6)  Rule 4.2B.a - N-well to N-well spacing 
;//     The rule specifies the distance as "0 or m 0.9" - this is
;//     assumed to mean that the spacing must be exactly 0 or a minimum
;//     of 0.9um.
;//
;// 7)  Rule 4.2B.c/d - N-well Resistor spacing 
;//     N-well resistor includes the terminals which are NOT covered by
;//     the resistor ID layer.
;//
;// 8)  Rules 4.2C/D - N-well Resistor definition
;//     Rule 2C is interpreted as WSYMBOL edges must coincide with N-well edges
;//     for the resistor sidewalls.  Rule 2D is interpreted as RSYMBOL edges must
;//     butt to N+ diffusions for the resistor terminals.  The check was
;//     implemented as: each edge of RSYMBOL must coincide with an N-well edge or
;//     must butt at least partially to N+ Diffusion terminals.
;//
;// 9)  Rules 4.4C/5C/9C - VTxxx Spacing Rules
;//     The document describes these rules as spacing between the given
;//     layer and the VTNL layer.  This is a typographical error - it
;//	should be a standard spacing rule - within the same layer.  For
;//	example, rule 4.4C is defined as the "Minimum VTPL to VTLN
;//	spacing" but the drawing specifies the separation between two
;//	edges of VTPL.  (Rules 4.7C and 4.8C are defined correctly.)
;//
;// 10) Rules 4.14A,B,C - Minimum Poly width for NMOS/PMOS/interconnect
;//     A general rule checking for ANY poly width < 0.18um was implemented.
;
;// 11) Rules 4.14A, 4.14B - Minimum Poly width for NMOS/PMOS devices
;//     This rule is specified as a minimum "poly" width, not as a minimum
;//     "Diffusion device" polygon width.  Thus, these checks are all performed with
;//     respect to the edges of the "gate" that butt diffusion and not the "edges"
;//     that butt field poly because these are NOT real poly edges.
;//
;// 12) Rule 4.14K - Max. Poly Overlap Diffusion area = 80um x 80um
;//     It is assumed that this is a pure area rule (6400 sq. micron) and NOT a
;//     width and length limitation.  (STS assumption)
;//
;// 13) Rules 4.16M and 4.17M - Soft contacts are prohibited
;//     Soft contacts refer to the creation of an electrical connection between
;//     butted diffusions through the salicide, allowing for only one of the
;//     diffusions to be connected to Metal1 through contacts.  This is not
;//     allowed; BOTH diffusions must be connected to Metal1 through contacts.
;//     These checks were implemented as part of rules 4.16F and 4.17F which
;//     indicate the butting diffusions must be at the same potential
;//     (electrically connected).  
;//
;// 14) Rule 4.18D - Minimum SAB Width
;//     It is assumed that this rule applies ONLY in the direction that is
;//     perpendicular to the gate.
;//
;// 15) Rule 4.18J through 4.18R - Non-Salicide Resistor rules
;//     A diffusion resistor is assumed to be an Diffusion with SAB overlap and no
;//     Poly overlap.  Also, a poly resistor is assumed to be a field poly with
;//     SAB overlap.
;//
;// 16) Rules 4.20D, 4.21C, 4.22D, 4.23C, 4.24D, 4.25C, 4.26D, 4.27C
;//     4.28D, 4.30C and 4.31C - Metal overlap Via rules
;//     The basic rule for this is that there are two different overlap values and
;//     that at least one set of opposing sides must have the larger overlap over
;//     the ENTIRE LENGTH of those sides.
;//
;// 17) Rules 6.1 - Metal Slot Rules
;//     These rules were updated to "ignore" pad metals.  It is assumed
;//     that pad metal is defined as metal overlapping pad layer.
;//
;// Rules not Coded:
;//
;// 4.1H.a/b - Metal1 Field Transistors, no description in manual
;// 4.14L/M and 4.19H - ... many contacts as
;//     possible into a diffusion can not be implemented.
;// 4.18D - DRC file does not determine which side of device drain.
;// Latchup IO guidelines not implemented.
;//
;//////////////////////////////////////////////////////////////////////
; 
; ********  Input Layer Definitions  ********
; 
drcExtractRules(
  layerDefs( "gds2"
    DIFF     = layer( 1 type(0) )   ; Active
    NWEL     = layer( 3 type(0) )   ; N-Well
    TWEL     = layer( 6 type(0) )   ; T-Well
    PPLUS    = layer( 11 type(0) )  ; P+ Implant
    NPLUS    = layer( 12 type(0) )  ; N+ Implant
    VTPL     = layer( 20 type(0) )  ; Low Vt PMOS
    VTPHL    = layer( 21 type(0) )  ; Thick gate ALow Vt PMOS
    VTNL     = layer( 22 type(0) )  ; Low Vt NMOS; Thick gate Zero Vt NMOS
    VTNI     = layer( 23 type(0) )  ; Zero Vt NMOS
    VTNHL    = layer( 24 type(0) )  ; Thick gate Low Vt NMOS
    PESD     = layer( 32 type(0) )  ; PESD
    SAB      = layer( 36 type(0) )  ; Salicide Block
    TG       = layer( 37 type(0) )  ; Thick Gate
    HR       = layer( 38 type(0) )  ; HR
    CONT     = layer( 39 type(0) )  ; Contact
    NWR      = layer( 40 type(0) )  ; alternate use of reserved layer for resistor
    PO1      = layer( 41 type(0) )  ; Poly
    ME1      = layer( 46 type(0) )  ; Metal1
    VI1      = layer( 47 type(0) )  ; Via1
    ME2      = layer( 48 type(0) )  ; Metal2
    VI2      = layer( 49 type(0) )  ; Via2
    ME3      = layer( 50 type(0) )  ; Metal3
    VI3      = layer( 51 type(0) )  ; Via3
    ME4      = layer( 52 type(0) )  ; Metal4
    VI4      = layer( 53 type(0) )  ; Via4
    ME5      = layer( 54 type(0) )  ; Metal5
    VI5      = layer( 55 type(0) )  ; Via5
    ME6      = layer( 56 type(0) )  ; Metal6
    PAD      = layer( 66 type(0) )  ; Pad
    MMC      = layer( 65 type(0) )  ; MMC
    M1SLMK   = layer( 72 type(7) )  ; Metal-1 Slot Marking Layer
    M2SLMK   = layer( 73 type(7) )  ; Metal-2 Slot Marking Layer
    M3SLMK   = layer( 74 type(7) )  ; Metal-3 Slot Marking Layer
    M4SLMK   = layer( 75 type(7) )  ; Metal-4 Slot Marking Layer
    M5SLMK   = layer( 76 type(7) )  ; Metal-5 Slot Marking Layer
    M6SLMK   = layer( 77 type(7) )  ; Metal-6 Slot Marking Layer
    rsymbol  = layer( 81 type(0) )  ; Diffusion Resistor ID
    psymbol  = layer( 82 type(0) )  ; Poly Resistor ID
    wsymbol  = layer( 83 type(0) )  ; N-Well Resistor ID
    IOMARK   = layer( 87 type(0) )  ; I/O Area Marker
    IOID     = layer( 91 type(0) )  ; Marker layer for ESD protection devices
    CSYMBOL  = layer( 112 type( 30 ) )  ; Capacitor Marker layer
    DSYMBOL  = layer( 114 type( 30 ) )  ; Diode Marker layer
    rom_id   = layer( 93 type(0) )  ; ROM Marker
    dp_id    = layer( 94 type(20) ) ; Dual Port SRAM Marker
    dp_id1   = layer( 94 type(21) ) ; Dual Port SRAM Marker
    dp_id2   = layer( 94 type(22) ) ; Dual Port SRAM Marker
    blsp_id1 = layer( 95 type(0) )  ; Borderless Single Port SRAM Marker
    cellmark = layer( 95 type(1) )  ; SRAM Marker
    blsp_id2 = layer( 95 type(20) ) ; Borderless Single Port SRAM Marker
    blsplp   = layer( 95 type( 21 ) ) ; Borderless SP SPRAM ID layer
    bdsp_id  = layer( 98 type(0) )  ; Bordered Single Port SRAM Marker
    MCAP     = layer( 112 type(36) ); Metal Dummy Block for Metal Cap.
    DIOBLK   = layer( 115 type(30) ); DRC Diode Block Layer
    LSYMBOL  = layer( 117 type(30) ); Inductor Marker Layer
    IND      = layer( 117 type(36) ); Metal Dummy Block Layer for Inductor
    chip_ext = cellBoundary( "" )   ; Chip Extent

    po_textt    = textToPin( 41 )
    m1_textt    = textToPin( 46 )
    m2_textt    = textToPin( 48 )
    m3_textt    = textToPin( 50 )
    m4_textt    = textToPin( 52 )
    m5_textt    = textToPin( 54 )
    m6_textt    = textToPin( 56 )

    po_text     = textToPin( 100 ) ; Poly Text Layer
    m1_text     = textToPin( 101 ) ; Metal-1 Text Layer
    m2_text     = textToPin( 102 ) ; Metal-2 Text Layer
    m3_text     = textToPin( 103 ) ; Metal-3 Text Layer
    m4_text     = textToPin( 104 ) ; Metal-4 Text Layer
    m5_text     = textToPin( 105 ) ; Metal-5 Text Layer
    m6_text     = textToPin( 106 ) ; Metal-6 Text Layer

    po_pin      = textToPin( 41 )  ; dummy definition
    m1_pin      = textToPin( 46 )  ; dummy definition
    m2_pin      = textToPin( 48 )  ; dummy definition
    m3_pin      = textToPin( 50 )  ; dummy definition
    m4_pin      = textToPin( 52 )  ; dummy definition
    m5_pin      = textToPin( 54 )  ; dummy definition
    m6_pin      = textToPin( 56 )  ; dummy definition

  ) ; layerDefs complete

  layerDefs( "df2"
   ;namein   = layer( df2_name type("drawing") )  ; name
    DIFF     = layer( "DIFF" type("drawing") )    ; Active
    NWEL     = layer( "NWEL" type("drawing") )    ; N-Well
    TWEL     = layer( "TWEL" type("drawing") )    ; T-Well
    PPLUS    = layer( "PPLUS" type("drawing") )   ; P+ Implant
    NPLUS    = layer( "NPLUS" type("drawing") )   ; N+ Implant
    VTPL     = layer( "VT" type("VTPL") )    ; Low Vt PMOS
    VTPHL    = layer( "VTPHL" type("drawing") )   ; Thick gate Low Vt PMOS
    VTNL     = layer( "VT" type("VTNL") )    ; Low Vt NMOS; Thick gate Zero Vt NMOS
    VTNI     = layer( "VTNI" type("drawing") )    ; Zero Vt NMOS
    VTNHL    = layer( "VTNHL" type("drawing") )   ; Thick gate Low Vt NMOS
    PESD     = layer( "PESD" type("drawing") )    ; PESD
    SAB      = layer( "SAB" type("drawing") )     ; Salicide block
    TG       = layer( "TG" type("drawing") )      ; Thick Gate
    HR       = layer( "HR" type("drawing") )      ; HR
    CONT     = layer( "CONT" type("drawing") )    ; Contact
    NWR      = layer( "NWR" type("drawing") ); alternate use of reserved layer for resistor
    PO1      = layer( "PO1" type("drawing") )     ; Poly
    ME1      = layer( "ME1" type("drawing") )     ; Metal1
    VI1      = layer( "VI1" type("drawing") )     ; Via1
    ME2      = layer( "ME2" type("drawing") )     ; Metal2
    VI2      = layer( "VI2" type("drawing") )     ; Via2
    ME3      = layer( "ME3" type("drawing") )     ; Metal3
    VI3      = layer( "VI3" type("drawing") )     ; Via3
    ME4      = layer( "ME4" type("drawing") )     ; Metal4
    VI4      = layer( "VI4" type("drawing") )     ; Via4
    ME5      = layer( "ME5" type("drawing") )     ; Metal5
    VI5      = layer( "VI5" type("drawing") )     ; Via5
    ME6      = layer( "ME6" type("drawing") )     ; Metal6    
    PAD      = layer( "TMV_RDL" type("drawing") )      ; Pad
    MMC      = layer( "MMC" type("drawing") )     ; MMC
    M1SLMK   = layer( "M1_CAD" type("Slot_Mark") )    ; Metal-1 Slot Marking Layer
    M2SLMK   = layer( "M2_CAD" type("Slot_Mark") )    ; Metal-2 Slot Marking Layer
    M3SLMK   = layer( "M3_CAD" type("Slot_Mark") )    ; Metal-3 Slot Marking Layer
    M4SLMK   = layer( "M4_CAD" type("Slot_Mark") )    ; Metal-4 Slot Marking Layer
    M5SLMK   = layer( "M5_CAD" type("Slot_Mark") )    ; Metal-5 Slot Marking Layer
    M6SLMK   = layer( "M6_CAD" type("Slot_Mark") )    ; Metal-6 Slot Marking Layer
    rsymbol  = layer( "RSYMBOL" type("drawing") ) ; Diffusion Resistor ID
    psymbol  = layer( "PSYMBOL" type("drawing") ) ; Poly Resistor ID
    wsymbol  = layer( "WSYMBOL" type("drawing") ) ; N-Well Resistor ID
    IOMARK   = layer( "IOMARK" type("drawing") )  ; I/O Area Marker
    IOID     = layer( "IOID" type("drawing") )    ; Marker layer for ESD protection devices
    rom_id   = layer( "SP" type("ROM_ID") )   ; ROM Marker
    dp_id    = layer( "DP" type("DP_ID") )    ; Dual Port SRAM Marker
    dp_id1   = layer( "DP" type("DP_ID1") )     ; Dual Port SRAM Marker
    dp_id2   = layer( "DP" type("DP_ID2") )    ; Dual Port SRAM Marker
    blsplp   = layer( "SP" type("BLSPLP") )  ; Borderless SP SPRAM ID layer
    bdsp_id  = layer( "SP" type("BDSP_ID") )  ; Bordered Single Port SRAM Marker
    blsp_id1 = layer( "SP" type("BLSP_ID1") )      ; Borderless Single Port SRAM Marker
    blsp_id2 = layer( "SP" type("BLSP_ID2") )   ; Borderless Single Port SRAM Marker
    cellmark = layer( "SP" type("CELLMARK") )   ; SRAM Marker
    MCAP     = layer( "MMC" type("MCAP") )     ; Metal Dummy Block for Metal Cap.
    DIOBLK   = layer( "SYMBOL" type("DIOBLK") )   ; DRC Diode Block Layer
    LSYMBOL  = layer( "SYMBOL" type("LSYMBOL") )  ; Inductor Marker Layer
    IND      = layer( "IND_CAD" type("IND") )      ; Metal Dummy Block Layer for Inductor
    CSYMBOL  = layer( "SYMBOL" type("CSYMBOL") )  ; Capacitor Marker layer
    DSYMBOL  = layer( "SYMBOL" type("DSYMBOL") )  ; Diode Marker layer
    chip_ext = cellBoundary( "" )                 ; Chip Extent

    po_textt    = textToPin( "PO_TEXT" ) ; Poly Text
    m1_textt    = textToPin( "M1_TEXT" ) ; Metal-1 Text
    m2_textt    = textToPin( "M2_TEXT" ) ; Metal-2 Text
    m3_textt    = textToPin( "M3_TEXT" ) ; Metal-3 Text
    m4_textt    = textToPin( "M4_TEXT" ) ; Metal-4 Text
    m5_textt    = textToPin( "M5_TEXT" ) ; Metal-5 Text
    m6_textt    = textToPin( "M6_TEXT" ) ; Metal-6 Text

    po_text     = textToPin( "PO1" )
    m1_text     = textToPin( "ME1" )
    m2_text     = textToPin( "ME2" )
    m3_text     = textToPin( "ME3" )
    m4_text     = textToPin( "ME4" )
    m5_text     = textToPin( "ME5" )
    m6_text     = textToPin( "ME6" )

    po_pin      = pinText( "PO1" )
    m1_pin      = pinText( "ME1" )
    m2_pin      = pinText( "ME2" )
    m3_pin      = pinText( "ME3" )
    m4_pin      = pinText( "ME4" )
    m5_pin      = pinText( "ME5" )
    m6_pin      = pinText( "ME6" )

  ) ; layerDefs complete
;
; Note: Undefined Layers - The following layers are assumed to be
;       generated and are therefore not defined:
;       - PWELL Layer
;       - Vtn Layer
;       - P-Layer
;       - N-Layer
;
; ******  Merge Input Layers  ******
;


;Offgrid checks -- added by Venky (Sankalp Semiconductor Pvt Ltd) on 9th Aug 2010
;GRID = 0.01um
offGrid(DIFF 0.01 "off grid polygon on layer DIFF")
offGrid(NWEL 0.01 "off grid polygon on layer NWEL")
offGrid(TWEL 0.01 "off grid polygon on layer TWEL")
offGrid(PPLUS 0.01 "off grid polygon on layer PPLUS")
offGrid(NPLUS 0.01 "off grid polygon on layer NPLUS")
offGrid(VTPL 0.01 "off grid polygon on layer VTPL")
offGrid(VTPHL 0.01 "off grid polygon on layer VTPHL")
offGrid(VTNL 0.01 "off grid polygon on layer VTNL")
offGrid(VTNI 0.01 "off grid polygon on layer VTNI")
offGrid(VTNHL 0.01 "off grid polygon on layer VTNHL")
offGrid(PESD 0.01 "off grid polygon on layer PESD")
offGrid(SAB 0.01 "off grid polygon on layer SAB")
offGrid(TG 0.01 "off grid polygon on layer TG")
offGrid(HR 0.01 "off grid polygon on layer HR")
offGrid(CONT 0.01 "off grid polygon on layer CONT")
offGrid(NWR 0.01 "off grid polygon on layer NWR")
offGrid(PO1 0.01 "off grid polygon on layer PO1")
offGrid(ME1 0.01 "off grid polygon on layer ME1")
offGrid(VI1 0.01 "off grid polygon on layer VI1")
offGrid(ME2 0.01 "off grid polygon on layer ME2")
offGrid(VI2 0.01 "off grid polygon on layer VI2")
offGrid(ME3 0.01 "off grid polygon on layer ME3")
offGrid(VI3 0.01 "off grid polygon on layer VI3")
offGrid(ME4 0.01 "off grid polygon on layer ME4")
offGrid(VI4 0.01 "off grid polygon on layer VI4")
offGrid(ME5 0.01 "off grid polygon on layer ME5")
offGrid(VI5 0.01 "off grid polygon on layer VI5")
offGrid(ME6 0.01 "off grid polygon on layer ME6")
offGrid(PAD 0.01 "off grid polygon on layer PAD")
offGrid(MMC 0.01 "off grid polygon on layer MMC")
offGrid(M1SLMK 0.01 "off grid polygon on layer M1SLMK")
offGrid(M2SLMK 0.01 "off grid polygon on layer M2SLMK")
offGrid(M3SLMK 0.01 "off grid polygon on layer M3SLMK")
offGrid(M4SLMK 0.01 "off grid polygon on layer M4SLMK")
offGrid(M5SLMK 0.01 "off grid polygon on layer M5SLMK")
offGrid(M6SLMK 0.01 "off grid polygon on layer M6SLMK")
offGrid(rsymbol 0.01 "off grid polygon on layer rsymbol")
offGrid(psymbol 0.01 "off grid polygon on layer psymbol")
offGrid(wsymbol 0.01 "off grid polygon on layer wsymbol")
offGrid(IOMARK 0.01 "off grid polygon on layer IOMARK")
offGrid(IOID 0.01 "off grid polygon on layer IOID")
offGrid(rom_id 0.01 "off grid polygon on layer rom_id")
offGrid(dp_id 0.01 "off grid polygon on layer dp_id")
offGrid(dp_id1 0.01 "off grid polygon on layer dp_id1")
offGrid(dp_id2 0.01 "off grid polygon on layer dp_id2")
offGrid(blsplp 0.01 "off grid polygon on layer blsplp")
offGrid(bdsp_id 0.01 "off grid polygon on layer bdsp_id")
offGrid(blsp_id1 0.01 "off grid polygon on layer blsp_id1")
offGrid(blsp_id2 0.01 "off grid polygon on layer blsp_id2")
offGrid(cellmark 0.01 "off grid polygon on layer cellmark")
offGrid(MCAP 0.01 "off grid polygon on layer MCAP")
offGrid(DIOBLK 0.01 "off grid polygon on layer DIOBLK")
offGrid(LSYMBOL 0.01 "off grid polygon on layer LSYMBOL")
offGrid(IND 0.01 "off grid polygon on layer IND")
offGrid(CSYMBOL 0.01 "off grid polygon on layer CSYMBOL")
offGrid(DSYMBOL 0.01 "off grid polygon on layer DSYMBOL")



  nwrdummy = geomOr( wsymbol NWR )
  IO      = geomOr( IOMARK IOID )
  ROM     = geomOr( rom_id )
  DP      = geomOr( dp_id )
  BLSP    = geomOr( blsp_id1 )
  BLSP1   = geomOr( blsp_id2 )
  DP2     = geomOr( dp_id2 )
  BDSP    = geomOr( bdsp_id DP2 )
  DP1     = geomOr( dp_id1 )
  BLSPLP= geomOr( blsplp )
  
  SPRAM   = geomOr( BDSP BLSP )
  BDDP  = geomOr( BDSP DP )
  BLDP    = geomOr( BLSP DP )
  SRAM    = geomOr( SPRAM DP )
    
  MARK_A = geomOr( SPRAM BLSP1 DP1 BLSPLP )
  MARK_B = geomOr( BLSP1 BLSPLP )
  MARK_C = geomOr( BLSP BLSP1 BLSPLP )
  MARK_D = geomOr( SPRAM BLSP1 )
  MARK_E = geomOr( BLDP BLSP1 BLSPLP )
  MARK_F = geomOr( IO SRAM DP1 BLSP1 )
  MARK_G = geomOr( SPRAM ROM BLSP1 DP1 BLSPLP )
  MARK_H = geomOr( BLSP BLSP1 DP BLSPLP )
  MARK_I = geomOr( SRAM BLSP1 DP1 BLSPLP )
  MARK_J = geomOr( SRAM ROM BLSP1 DP1 BLSPLP )

;
; ******  Define NWELL Resistor  ****** 

  nwell = geomAndNot( NWEL TWEL )              ; NWELL without Twell
  nwres     = geomOverlap( nwell nwrdummy )    ; N-Well resistor
  welnotr   = geomAndNot( NWEL nwres )         ; N-Well non-resistor
  wresbody = geomAnd( nwres nwrdummy )         ; NW Res Body
  wresnotbody = geomAndNot( nwres wresbody )   ; NW Res not Body
  wterm = geomButtOnly( wresnotbody wresbody ) ; NW Res Terminal
;
; ******  Define Basic Layers  ******
;
  expol = geomAndNot( PO1 DIFF )           ; Field Poly
  gate = geomAndNot( PO1 expol )           ; Gate Poly
  nact = geomAnd( DIFF NPLUS )             ; N+ Active
  pact = geomAnd( DIFF PPLUS )             ; P+ Active
  ngate = geomAnd( gate NPLUS )            ; All N+ Gates
  pgate = geomAnd( gate PPLUS )            ; All P+ Gates

  wpo = geomSize( PO1 -0.12 downUp )      ; ?? truncate smaller than .12 poly

  gate_edge = geomGetEdge( gate inside DIFF )   ; Gate edge facing S/D
  ngate_edge = geomGetEdge( ngate inside DIFF ) ; N+ Gate edge facing S/D
  pgate_edge = geomGetEdge( pgate inside DIFF ) ; P+ Gate edge facing S/D

  actpsub = geomOutside( DIFF NWEL )       ; Active in P-Sub
  actnwel = geomAndNot( DIFF actpsub )     ; Active in N-Well
  ;actnwel_logic = geomAndNot( actnwel geomOr( geomOr( SRAM DP1 ) BLSP1 ) )
  actnwel_ram = geomAnd( actnwel geomOr( geomOr( SRAM DP1 ) BLSP1 ) )
  actnt = geomOutside( actnwel TWEL )
  acttw = geomAndNot( actnwel actnt )
  actnt_logic = geomAndNot( actnt geomOr( geomOr( SRAM DP1 ) BLSP1 ) )
  nactpsub = geomAndNot( nact nwell )      ; N+ Active in P-Sub
  nactnwel = geomAndNot( nact nactpsub )   ; N+ Active in N-Well
  pactpsub = geomAndNot( pact nwell )      ; P+ Active in P-Sub
  pactnwel = geomAndNot( pact pactpsub )   ; P+ Active in N-Well

  ndiff = geomOr( geomAndNot( actpsub PPLUS ) geomAndNot( acttw PPLUS ) )
  pdiff = geomAnd( PPLUS actnt ) 
  ndiff1 = geomAvoiding( ndiff TG )
  ndiff3 = geomOverlap( ndiff TG )
  pdiff1 = geomAvoiding( pdiff TG ) 
  pdiff3 = geomOverlap( pdiff TG ) 

  ndiff1_logic = geomAndNot( ndiff1 geomOr( geomOr( SRAM DP1 ) BLSP1 ) )
  ndiff1_ram = geomAnd( ndiff1 geomOr( geomOr( SRAM DP1 ) BLSP1 ) ) 
  pdiff1_logic = geomAndNot( pdiff1 geomOr( geomOr( SRAM DP1 ) BLSP1 ) )
  pdiff1_ram = geomAnd( pdiff1 geomOr( geomOr( SRAM DP1 ) BLSP1 ) )

  ptap = geomOr( geomAnd( PPLUS actpsub ) geomAnd( PPLUS acttw ) )
  ntap = geomAndNot( actnt PPLUS )
  butt_pplus = geomGetEdge( PPLUS inside DIFF ) 
  psd = geomAndNot( pdiff ptap )           ; All P+ Src/Drn (P+ Diff in N-Well)
  nsd = geomAndNot( ndiff nwell )          ; All N+ Src/Drn (N+ Diff in P-Sub)
  ppsd = geomAndNot( psd PO1 )             ; All P+ Src/Drn not PO1 (P+ Diff in N-Well)
  npsd = geomAndNot( nsd PO1  )            ; All N+ Src/Drn not PO1 (N+ Diff in P-Sub)  
  nbtap = geomButting( ntap psd )          ; All N+ Butting taps (integrated ties)
  pbtap = geomButting( ptap nsd )          ; All P+ Butting taps (integrated ties)
  but_ps = geomButting( psd ntap )
  but_ns = geomButting( nsd ptap )
  allsd = geomCat( nsd psd )               ; All Source/Drain Diffusions
  allnpsd = geomCat( npsd ppsd )           ; All Source/Drain Diffusions not PO1
  diodes = geomAvoiding( allsd gate )      ; Junction diodes

  polcnt = geomOutside( CONT DIFF )
  difcnt = geomAndNot( CONT polcnt )
  difcnt3 = geomOverlap( difcnt TG )
  difcnt1 = geomAndNot( difcnt difcnt3 )

  co_psd = geomEnclose( psd difcnt )
  co_nsd = geomEnclose( nsd difcnt )
  co_sd = geomOr( co_psd co_nsd )

  co_allnpsd = geomEnclose( allnpsd difcnt )
  gate_w = drc( PO1 gate enc == 0 edgea opposite ) ; the edge of gate
  gate_wb = geomGetEdge( gate_w butting co_allnpsd )    ; gate of non-TG unrelated to S/D
  gate_wa = geomAndNot( gate_w gate_wb )           ; gate of non-TG  related to S/D

  wgate_wa = geomGetEdge( gate_wa coincident wpo )   ; The wide gate of nonTG & SD related gate
  wgate_wb = geomGetEdge( gate_wb coincident wpo )   ; The wide gate of nonTG & SD unrelated gate

  tgate_wa = geomAndNot( gate_wa wgate_wa )          ; The thin gate of nonTG & SD related gate
  tgate_wb = geomAndNot( gate_wb wgate_wb )          ; The thin gate of nonTG & SD unrelated gate

  expo_e = geomGetEdge( PO1 not_over gate )     ; expol edge
  intpol = geomAvoiding( expol CONT )

  ctfpol = geomOutside( CONT DIFF )        ; Field Poly Contact
  ctdiff = geomAndNot( CONT ctfpol )       ; Active Contact
  ctndiff = geomAnd( ctdiff NPLUS )        ; N+ Diffusion Contact
  ctpdiff = geomAnd( ctdiff PPLUS )        ; P+ Diffusion Contact
 
  twel = geomAnd( nwell TWEL )             ; Twin Well and Nwell
  twelnot = geomAndNot( TWEL twel )        ; Standard TWell

  ngate2 = geomAndNot( ngate TG )          ; 1.8V N+ Gates
  pgate2 = geomAndNot( pgate TG )          ; 1.8V P+ Gates
  gate2 = geomCat( ngate2 pgate2 )         ; All 1.8V Gates
  ngate3 = geomAndNot( ngate ngate2 )      ; 3.3V N+ Gates
  pgate3 = geomAndNot( pgate pgate2 )      ; 3.3V P+ Gates
  gate3 = geomCat( ngate3 pgate3 )         ; All 3.3V Gates
  nsd2 = geomAndNot( nsd TG )              ; 1.8V N+ Source/Drain
  psd2 = geomAndNot( psd TG )              ; 1.8V P+ Source/Drain
  nsd3 = geomAndNot( nsd nsd2 )            ; 3.3V N+ Source/Drain
  psd3 = geomAndNot( psd psd2 )            ; 3.3V P+ Source/Drain
  nwel3 = geomOverlap( welnotr TG )        ; N-Well with at least one 3.3V gate
  nwel2 = geomAndNot( welnotr nwel3 )      ; N-Well with at least one 1.8V gate
  twel2 = geomEnclose( twelnot gate2 )     ; T-Well with at least one 1.8V gate
  twel3 = geomEnclose( twelnot gate3 )     ; T-Well with at least one 3.3V gate

  if( avSwitch( "check_max_metal_space" )
    then
      chip_ext_dn500 = geomSize( chip_ext -500 )
    ) ; end if "check_max_metal_space"

;
; ****** DIFFUSION RULE ******
;
  e1AB = geomAndNot( geomOr( drc( DIFF width < 0.24 )
	      		     drc( DIFF width < 0.01 withCornerTouch fig ) )
                     MARK_A )
  errorLayer( e1AB "4.1A.a/b, 4.1B: Active width >= 0.24um." )

  e1C = geomAndNot( drc( DIFF sepNotch < 0.28 ) MARK_A )
  errorLayer( e1C "4.1C.a/b: Active spacing >= 0.28um." )

  e1Da = geomAndNot( geomOr( drc( NWEL ndiff1_logic sep < 0.43 )
	      		     drc( NWEL ndiff1_logic sep < 0.01 fig )
			     geomButting( NWEL ndiff1_logic ) )
                     BLSPLP )
	 	     ;MARK_B )
  errorLayer( e1Da "4.1D.a: Nwell to N+ spacing >= 0.43um (1.8V)." )

  e1Db = geomOr( drc( NWEL ndiff3 sep < 1.0 )
		 drc( NWEL ndiff3 sep < 0.01 fig )
		 geomButting( NWEL ndiff3 ) )
  errorLayer( e1Db "4.1D.b: Nwell to N+ spacing >= 1.00um (3.3V)." )

  e1E = geomAndNot( geomOr( drc( NWEL ntap enc < 0.24 with_perp ) 
                            geomButting( NWEL ntap ) ) BLSP )
  errorLayer( e1E "4.1E: Nwell overlap N-tap >= 0.24um." )

  e1F = geomOr( drc( NWEL ptap sep < 0.24 )
	  	drc( NWEL ptap sep < 0.01 fig )
		geomButting( NWEL ptap ) )
  errorLayer( e1F "4.1F: Nwell to P-tap spacing >= 0.24um." )

;  e1Ga = geomAndNot( geomOr( drc( NWEL pdiff1_logic enc < 0.43 with_perp ) ) MARK_B )
  e1Ga = geomAndNot( geomOr( drc( NWEL pdiff1_logic enc < 0.43 with_perp ) 
                             geomButting( NWEL pdiff1_logic ) ) BLSPLP )
  errorLayer( e1Ga "4.1G.a: Nwell overlap P+ Diffusion >= 0.43um (1.8V)." )
  
  e1Gb = geomOr( drc( NWEL pdiff3 enc < 1.00 with_perp ) )
  errorLayer( e1Gb "4.1G.b: Nwell overlap P+ Diffusion >= 1.00um (3.3V)." )
  
  e1EFG = geomStraddle( geomAndNot( DIFF MARK_B ) NWEL )
  errorLayer( e1EFG "4A.1E/1F/1G Warning : Diffusion straddle N-Well" )

;  e1Ha = geomAndNot( geomOr( drc( TWEL ndiff1 enc < 0.43 with_perp ) ) MARK_B )
  e1Ha = drc( TWEL ndiff1 enc < 0.43 with_perp ) 
  errorLayer( e1Ha "4.1H.a: Twell overlap N+ Diffusion >= 0.43um (1.8V)." )

  e1Hb = geomOr( drc( TWEL ndiff3 enc < 1.00 with_perp ) )
  errorLayer( e1Hb "4.1H.b: Twell overlap N+ Diffusion >= 1.00um (3.3V)." )

  e1I = geomOr( drc( TWEL ntap sep < 0.24 with_perp ) )
  errorLayer( e1I "4.1I: Twell spacing N-tap in N-Well >= 0.24um." )

  e1J = geomOr( drc( TWEL ptap enc < 0.24  with_perp ) )
  errorLayer( e1J "4.1J: Twell overlap P-tap >= 0.24um." )

  e1Ka = geomOr( drc( TWEL pdiff1 sep < 0.43 with_perp ) )
  errorLayer( e1Ka "4.1K.a: Twell to P+ spacing >= 0.43um (1.8V)." )

  e1Kb = geomOr( drc( TWEL pdiff3 sep < 1.00 with_perp ) )
  errorLayer( e1Kb "4.1K.b: Twell to P+ spacing >= 1.00um (3.3V)." )

;
; ****** N-WELL RULE ******
;
; Connection Definition for Equal Potential checks
;
  ntap_con = geomAnd( ntap CONT )
  
  geomConnect(
    via( CONT ME1   PO1 )
    via( ntap_con ME1 nwell )
    via( CONT ME1 ndiff )
    via( CONT ME1 pdiff )
    via( VI1 ME2 ME1 )
    via( VI2 ME3 ME2 )
    via( VI3 ME4 ME3 )
    via( VI4 ME5 ME4 )
    via( VI5 ME6 ME5 )
    via( ntap_con ME1 ntap )

    label( m1_text ME1 )
    label( m2_text ME2 )
    label( m3_text ME3 )
    label( m4_text ME4 )
    label( m5_text ME5 )
    label( m6_text ME6 )

    label( m1_textt ME1 )
    label( m2_textt ME2 )
    label( m3_textt ME3 )
    label( m4_textt ME4 )
    label( m5_textt ME5 )
    label( m6_textt ME6 )

    label( m1_pin ME1 )
    label( m2_pin ME2 )
    label( m3_pin ME3 )
    label( m4_pin ME4 )
    label( m5_pin ME5 )
    label( m6_pin ME6 )
    )

  if( ( avSwitch "Skip_Soft-Connect_Checks" ) then
    geomStamp( welnotr ntap )
  else
    geomStamp( welnotr ntap error )
  ) ; endif

  e2Aa = geomOr( drc( welnotr width < 0.90 )
	  	 drc( welnotr width < 0.01 withCornerTouch fig ) )
  errorLayer( e2Aa "4.2A.a: Minimum N-Well width is 0.9um" )

  e2Ab = geomOr( drc( nwres width < 1.50 )
	  	 drc( nwres width < 0.01 withCornerTouch fig ) )
  errorLayer( e2Ab "4.2A.b: Minimum width for N-Well resistor is 1.5um" )

  nwres_edge = geomGetEdge( wresbody inside nwres )
  e2Ac = geomGetLength( nwres_edge keep > 20 contiguous )
  errorLayer( e2Ac "4.2A.c Maximum width for N-Well resistor is 20um" )    
  
;
; Note: Rule 4.2B.a - N-well to N-well spacing 
;       The rule specifies the distance as "0 or m 0.9" - this is
;       assumed to mean that the spacing must be exactly 0 or a
;       minimum of 0.9um.
;
 
  e2Ba = geomOr( drc( welnotr sepNotch < 0.9 ) )
  errorLayer( e2Ba "4.2B.a: Minimum Equal Potential N-Well spacing is 0um or >= 0.9um" )

  e2Bb = drc( welnotr sep < 1.50 diffNet )
  errorLayer( e2Bb "4.2B.b1: Minimum Non-Equal Potential 1.8V N-Well spacing is 1.5um" )

;
; Note: Rule 4.2B.c/d - N-well Resistor spacing 
;       N-well resistor includes the terminals which are NOT covered
;       by the resistor ID layer.
;
  e2Bc = geomOr( drc( nwres NWEL 0 < sep < 2.20 ) )
  errorLayer( e2Bc "4.2B.c: Minimum N-Well resistor spacing is 2.2um" )

  e2C = geomAndNot( nwrdummy nwres )
  errorLayer( e2C "4.2C: N-Well Resistor overlap N-well is 0um." )

  wtermtap = geomAnd( ntap nwres )        ; N+ active in Nwell resistor terminal
  e2D = geomAnd( ntap wresbody )
  errorLayer( e2D "4.2D: N-Well Resistor to N+ Diffusion (for N-Well tap) is 0um." )
;
; Note: Rule 4.2C is interpreted as WSYMBOL edges must coincide with
;       N-well edges for the resistor sidewalls.  Rule 4.2D is
;       interpreted as RSYMBOL edges must butt to N+ diffusions for
;       the resistor terminals.  The check was implemented as: each
;       edge of RSYMBOL must coincide with an N-well edge or must butt
;       at least partially to N+ Diffusion terminals.
;
  rsup005 = geomSize( nwrdummy 0.005 edges )
  rsupedg = geomAnd( rsup005 wterm )
  rtrmntp = geomAnd( rsupedg wtermtap )
  trmndif = geomEnclose( rsupedg rtrmntp )
  rstrmbut = drc( nwrdummy trmndif sep == 0 opposite edgea )
  rsedgnow = geomAndNot( nwrdummy nwres edges )
  e2CD = geomAndNot( rsedgnow rstrmbut edges )
  errorLayer( e2CD 
    "4.2C/D: The resistor marker layer edges must either be entirely coincident 
     with N-Well edge or at least partially butted to N+ Tap (terminal)." )

;
; ****** T-WELL RULE ******
;
; Connection Definition for Equal Potential checks
;
  ptct = geomAnd( ptap CONT )  
  
  geomConnect(
    via( ptct ME1 twelnot )
    via( ptct ME1 twel )
    via( ptct ME1 twel2 )
    via( ptct ME1 twel3 )
    via( CONT ME1 ndiff )
    via( CONT ME1 pdiff )
    via( VI1 ME2 ME1 )
    via( VI2 ME3 ME2 )
    via( VI3 ME4 ME3 )
    via( VI4 ME5 ME4 )
    via( VI5 ME6 ME5 )
    )

  e3A = geomOr( drc( TWEL width < 0.90 )
	  	 drc( TWEL width < 0.01 withCornerTouch fig ) )
  errorLayer( e3A "4.3A: Minimum T-Well width is 0.9um" )

;                     
; Note: Rule 4.3B.a - T-well to T-well spacing 
;       The rule specifies the distance as "0 or m 0.9" - this is
;       assumed to mean that the spacing must be exactly 0 or a
;       minimum of 0.9um.
;  twel = geomAnd( nwell TWEL )             ; Twin Well and Nwell
;  twelnot = geomAndNot( TWEL twel )        ; Standard TWell

  e3Ba =   geomCat( drc( twelnot 0 < sep < 0.90 sameNet )
                    drc( twelnot 0 < notch < 0.90 ) )
  errorLayer( e3Ba "4.3B.a: Minimum Equal Potential T-Well spacing is 0um or >= 0.9um" )

  twelnot2 = geomAndNot( twelnot twel2 )
  e3Bb1 = geomCat(
                   geomOr( drc( twel2 sep < 1.50 diffNet ) )
                   geomOr( drc( twel2 twelnot2 sep < 1.50 ) )
                 )
  errorLayer( e3Bb1 "4.3B.b1: Minimum Non-Equal Potential 1.8V T-Well spacing is 1.5um" )

  twelnot3 = geomAndNot( twelnot twel3 )
  e3Bb2 = geomCat(
                   geomOr( drc( twel3 sep < 2.00 diffNet ) )
                   geomOr( drc( twel3 twelnot3 sep < 2.00 ) )
                 )
  errorLayer( e3Bb2 "4.3B.b2: Minimum Non-Equal Potential 3.3V T-Well spacing is 2.0um" )
 
  filledwell = geomNoHoles( NWEL )
  e3C1 = geomOr( drc( filledwell TWEL enc < 1.5 with_perp ) )
  errorLayer( e3C1 "4.3C: Minimum N-Well overlap T-Well is 1.5um" )
  
  e3C2 = geomAndNot( TWEL NWEL )
  errorLayer( e3C2 "4.3C: T-Well must be surrounded by N-Well." )

;
;***** VTPL RULE ********
;

; Note: The minimum width rules for the VTxxx layers are checked
;       differently depending on the value of the rule.  This rule
;       refers ONLY to the device length and not to the device width.
;       If the length and width of the device have the same minimum
;       rule, then a standard width check can be performed.  If the
;       minimum device length rule is different from the minimum
;       device width rule, then the rule must be checked against the
;       device length.  This applies to rules 4.4A, 4.5A, 4.7A, 4.8A
;       and 4.9A.  The minimum device width in all cases is 0.24um (as
;       specified by rule 4.1A).

  povtpl = geomAnd( pgate VTPL )

  e4A = geomOr( drc( povtpl width < 0.24 )
	  	drc( povtpl width < 0.01 withCornerTouch fig ) )
  errorLayer( e4A "4.4A: Minimum Poly width for PMOS is 0.24um" ) 
  
  e4B = geomOr( drc( VTPL width < 0.45 )
	  	drc( VTPL width < 0.01 withCornerTouch fig ) )
  errorLayer( e4B "4.4B: Minimum VTPL width is 0.45um" )

  e4C = drc( VTPL sepNotch < 0.45 ) 
  errorLayer( e4C "4.4C: Minimum VTPL spacing is 0.45um" )

;  e4D = geomOr( drc( VTPL pact enc < 0.30 ) )
  e4D = geomOr( drc( VTPL DIFF enc < 0.30 with_perp ) )
  errorLayer( e4D "4.4D: Minimum VTPL overlap Diffusion on the diffusion of related device is 0.3um" )
  
;  e4E = geomOr( drc( VTPL DIFF sep < 0.3 ) )
  e4E = geomOr( drc( VTPL DIFF sep < 0.3 with_perp ) )
  errorLayer( e4E "4.4E: Minimum VTPL to unrelated Diffusion spacing is 0.3um" )
  
  e4F = geomOr( drc( VTPL gate_edge enc < 0.4 ) )
  errorLayer( e4F "4.4F: Minimum VTPL overlap Poly of related device is 0.4um" )
  
  e4G = geomOr( drc( VTPL gate_edge sep < 0.4 ) )
  errorLayer( e4G "4.4G: Minimum VTPL to unrelated Poly spacing (in diffusion region) is 0.4um" ) 

;
;****** VTPHL RULE ******
;
  ovtphl = geomAnd( gate VTPHL )
  povtphl = geomAnd( pgate VTPHL )
  povtphl_edge = geomAnd( pgate_edge povtphl )
  ovtphl_edge = geomAnd( gate_edge ovtphl )

  vtphl_gate_length = geomGetEdge( povtphl inside PO1 )
  e5A = geomGetLength( vtphl_gate_length keep < 0.5 )
;  e5A = drc( povtphl_edge width < 0.5 )
  errorLayer( e5A "4.5A: Minimum Poly width for PMOS is 0.5um")

  e5B = geomOr( drc( VTPHL width < 0.45 )
	  	drc( VTPHL width < 0.01 withCornerTouch fig ) )
  errorLayer( e5B "4.5B: Minimum VTPHL width is 0.45um" )

  e5C = drc( VTPHL sepNotch < 0.45 ) 
  errorLayer( e5C "4.5C: Minimum VTPHL spacing is 0.45um" )

;  e5D = geomOr( drc( VTPHL pact enc < 0.3  ) )
  e5D = geomOr( drc( VTPHL DIFF enc < 0.3 with_perp ) )
  errorLayer( e5D "4.5D: Minimum VTPHL overlap Diffusion on the diffusion of related device is 0.3um" )

  e5E = geomOr( drc( VTPHL DIFF sep < 0.3 with_perp ) )
  errorLayer( e5E "4.5E: Minimum VTPHL to unrelated Diffusion spacing is 0.3um" )

  e5F = geomOr( drc( VTPHL ovtphl_edge enc < 0.4 ) )
  errorLayer( e5F "4.5F: Minimum VTPHL overlap Poly of related device is 0.4um" )

  e5G = geomOr( drc( VTPHL gate_edge sep < 0.4 ) )
  errorLayer( e5G "4.5G: Minimum VTPHL to unrelated Poly spacing (in diffusion region) >= 0.4um" )

;
;****** VTNL RULE ******
;

  povtnl1 = geomAnd( ngate VTNL )
  povtnl3 = geomAnd( povtnl1 TG )
  povtnl3_edge = geomAnd( ngate_edge povtnl3 )
    
  e7Aa = geomOr( drc( povtnl1 width < 0.24 )
	  	 drc( povtnl1 width < 0.01 withCornerTouch fig ) )
  errorLayer( e7Aa "4.7A.a: Minimum Poly width for NMOS (1.8V device) is 0.24um" )

  e7Ab = drc( povtnl3_edge width < 0.5 )
  errorLayer( e7Ab "4.7A.b: Minimum Poly width for NMOS (3.3V device) is 0.5um" ) 

  e7B = geomOr( drc( VTNL width < 0.45 )
	  	drc( VTNL width < 0.01 withCornerTouch fig ) )
  errorLayer( e7B "4.7B: Minimum VTNL width is 0.45um" )

  e7C = drc( VTNL sepNotch < 0.45 ) 
  errorLayer( e7C "4.7C: Minimum VTNL spacing is 0.3um" )

;  e7D = geomOr( drc( VTNL nact enc < 0.30 ) )
  e7D = geomOr( drc( VTNL nact enc < 0.30 with_perp ) )
  errorLayer( e7D "4.7D: Minimum VTNL overlap Diffusion on the diffusion of related device is 0.3um" )

;  e7E = geomOr( drc( VTNL DIFF sep < 0.3 ) )
  e7E = geomOr( drc( VTNL DIFF sep < 0.3 with_perp ) )
  errorLayer( e7E "4.7E: Minimum VTNL to unrelated Diffusion spacing is 0.3um" )

  e7F = geomOr( drc( VTNL gate_edge enc < 0.4 ) )
  errorLayer( e7F "4.7F: Minimum VTNL overlap Poly of related device is 0.4um" )
  
  e7G = geomOr( drc( VTNL gate_edge sep < 0.4 ) )
  errorLayer( e7G "4.7G: Minimum VTNL to unrelated Poly spacing (in diffusion region) is 0.4um" ) 

;
;****** VTNI RULE ******
;
  ovtni1 = geomAnd( gate VTNI )
  povtni1 = geomAnd( ngate VTNI )
  povtni1_edge = geomAnd( ngate_edge povtni1 )
  ovtni1_edge = geomAnd( gate_edge ovtni1 )
    
  e8A = drc( povtni1_edge width < 0.3 )
  errorLayer( e8A "4.8A: Minimum Poly width for NMOS is 0.3um" )

  e8B = geomOr( drc( VTNI width < 0.45 )
	  	drc( VTNI width < 0.01 withCornerTouch fig ) )
  errorLayer( e8B "4.8B: Minimum VTNI width is 0.45um" )
 
  e8C = drc( VTNI sepNotch < 0.45 ) 
  errorLayer( e8C "4.8C: Minimum VTNI spacing is 0.45um" )

;  e8D = geomOr( drc( VTNI nact enc < 0.30 ) )
  e8D = geomOr( drc( VTNI nact enc < 0.30 with_perp ) )
  errorLayer( e8D "4.8D: Minimum VTNI overlap Diffusion on the diffusion of related device is 0.3um" )

;  e8E = geomOr( drc( VTNI DIFF sep < 0.3 ) )
  e8E = geomOr( drc( VTNI DIFF sep < 0.3 with_perp ) )
  errorLayer( e8E "4.8E: Minimum VTNI to unrelated Diffusion spacing is 0.3um" )

  e8F = geomOr( drc( VTNI ovtni1_edge enc < 0.4 ) )
  errorLayer( e8F "4.8F: Minimum VTNI overlap Poly of related device is 0.4um" )

  e8G = geomOr( drc( VTNI gate_edge sep < 0.4 ) )
  errorLayer( e8G "4.8G: Minimum VTNI to unrelated Poly spacing (in diffusion region) is 0.4um" ) 

; 
;****** VTNHL RULE ******
;

  ovtnhl1 = geomAnd( gate VTNHL )
  povtnhl1 = geomAnd( ngate VTNHL )
  povtnhl1_edge = geomAnd( ngate_edge povtnhl1 )
  ovtnhl1_edge = geomAnd( gate_edge ovtnhl1 )   

  vtnhl_gate_length = geomGetEdge( povtnhl1 inside PO1 )
  e9A = geomGetLength( vtnhl_gate_length keep < 0.5 )
;  e9A = drc( povtnhl1_edge width < 0.5 )
  errorLayer( e9A "4.9A: Minimum Poly width for NMOS is 0.5um" )

  e9B = geomOr( drc( VTNHL width < 0.45 )
	  	drc( VTNHL width < 0.01 withCornerTouch fig ) )
  errorLayer( e9B "4.9B: Minimum VTNHL width is 0.45um" )

  e9C = drc( VTNHL sepNotch < 0.45 ) 
  errorLayer( e9C "4.9C: Minimum VTNHL spacing is 0.45um" )

;  e9D = geomOr( drc( VTNHL nact enc < 0.30 ) )
  e9D = geomOr( drc( VTNHL nact enc < 0.30 with_perp ) )
  errorLayer( e9D "4.9D: Minimum VTNHL overlap Diffusion on the diffusion of related device is 0.3um" )
  
;  e9E = geomOr( drc( VTNHL DIFF sep < 0.3 ) )
  e9E = geomOr( drc( VTNHL DIFF sep < 0.3 with_perp ) )
  errorLayer( e9E "4.9E: Minimum VTNHL to unrelated Diffusion spacing is 0.3um" )

  e9F = geomOr( drc( VTNHL ovtnhl1_edge enc < 0.4 ) )
  errorLayer( e9F "4.9F: Minimum VTNHL overlap Poly of related device is 0.4um" )

  e9G = geomOr( drc( VTNHL gate_edge sep < 0.4 ) )
  errorLayer( e9G "4.9G: Minimum VTNHL to unrelated Poly spacing is 0.4um" ) 
            
;
; ****** TG RULE ******
;

  e13A = geomOr( drc( TG width < 0.45 )
 	  	 drc( TG width < 0.01 withCornerTouch fig ) )
  errorLayer( e13A "4.13A: Minimum TG width is 0.45um" )

  e13B = drc( TG sepNotch < 0.45 ) 
  errorLayer( e13B "4.13B: Minimum TG spacing is 0.45um" )

  e13C = geomOr( drc( TG DIFF 0 < enc < 0.30 ) 
                 drc( TG DIFF enc < 0.01 fig ) )
  errorLayer( e13C "4.13C: Minimum TG overlap Diffusion on the diffusion of 3.3V device is 0.3um" )

  e13D = geomOr( drc( TG DIFF sep < 0.30 ) 
                 drc( TG DIFF sep < 0.01 fig ))
  errorLayer( e13D "4.13D: Minimum TG to unrelated Diffusion spacing is 0.3um" )

  gt3up4 = geomSizeAnd( gate3 DIFF 0.2 0.4 )
  e13E = geomAndNot( gt3up4 TG )
  errorLayer( e13E "4.13E: Minimum TG overlap Poly of 3.3V device is 0.4um" )

  gt2up4 = geomSizeAnd( gate2 DIFF 0.2 0.4 )
  e13F = geomAnd( gt2up4 TG )
  errorLayer( e13F "4.13F: Minimum TG to unrelated Poly spacing is 0.4um" )

;
; ****** POLY RULE ******
;
; Note: A general rule checking for ANY poly width < 0.18um was implemented.

  e14ABC = geomAndNot( geomOr( drc( PO1 width < 0.18 )
	      		      drc( PO1 width < 0.01 withCornerTouch fig ) )
                      MARK_A )
  errorLayer( e14ABC "4.14A/B/C: Minimum  Poly width is 0.18um." )

;
; Note: Rules 4.14A/B - Minimum Poly width for NMOS/PMOS devices
;       This rule is specified as a minimum "poly" width, not as a
;       minimum "Diffusion device" polygon width.  Thus, these checks are
;       all performed with respect to the edges of the "gate" that
;       butt diffusion and not the "edges" that butt field poly
;       because these are NOT real poly edges.
;

;  gtedgnsd3 = drc( ngate3 nsd3 sep == 0 edgea opposite )

  gtedgnsd3 = geomGetEdge( ngate3 inside nact )
  e14Ab = drc( gtedgnsd3 width < 0.34 )
  errorLayer( e14Ab "4.14A.b: Minimum Poly width for NMOS (3.3V device) is 0.34um" )
  
;  gtedgpsd3 = drc( pgate3 psd3 sep == 0 edgea opposite )

  gtedgpsd3 = geomGetEdge( pgate3 inside pact )
  e14Bb = drc( gtedgpsd3 width < 0.34 )
  errorLayer( e14Bb "4.14B.b: Minimum Poly width for PMOS (3.3V device) is 0.34um" )

;
; Note: The following check only looks at source/drain diffusion
;       without considering butted tap diffusions since soft contacts
;       are not allowed.  Soft contacts are defined as butted
;       diffusions where the current is expected to flow across the
;       salicide so only one of the diffusions has an actual contact
;       to Metal1.
;
  sdwct = geomEnclose( allsd CONT )     ; Source/Drain Diffusion w/contact
  sdwoct = geomAndNot( allsd sdwct )    ; Source/Drain Diffusion w/o contact
  
  npsdwct = geomEnclose( allnpsd CONT )     ; Source/Drain Diffusion w/contact (new add)
  npsdwoct = geomAndNot( allnpsd npsdwct )  ; Source/Drain Diffusion w/o contact (new add)
    
;
; Note: According to the following definition of "smgate" and
;       "bigate", a single gate poly can be composed of both "smgate"
;       and "bigate".
;
  bigate = geomSize( gate -.12 downUp )
  smgate = geomAndNot( gate bigate )

;  gtsdedg = drc( smgate sdwoct sep == 0 edgea opposite )
;  gtsdvio = drc( gtsdedg 0 < sep < 0.28 shielded )
;  e14Da1 = geomAndNot( gtsdvio MARK_C )
;  errorLayer( e14Da1 "4.14D.a1: Small Gate Poly (width <= 0.24um) spacing over diffusion w/o contact is 0.28um" )

  co_psd = geomEnclose( psd ctdiff )
  co_nsd = geomEnclose( nsd ctdiff )
  co_psd = geomEnclose( ppsd ctdiff )
  co_nsd = geomEnclose( npsd ctdiff )
  co_sd = geomOr( co_psd co_nsd )
; note : original "gate_wb" is wrong coding
  co_allnpsd = geomEnclose( allnpsd ctdiff )
  gate_w = drc( PO1 gate enc == 0 edgea opposite ) ; the edge of gate
;  gate_wb = geomGetEdge( gate_w butting co_sd )    ; gate of non-TG unrelated to S/D
  gate_wb = geomGetEdge( gate_w butting co_allnpsd )    ; gate of non-TG unrelated to S/D
  gate_wa = geomAndNot( gate_w gate_wb )           ; gate of non-TG  related to S/D
  wgate_wa = geomGetEdge( gate_wa coincident wpo )   ; The wide gate of nonTG & SD related gate
  tgate_wa = geomAndNot( gate_wa wgate_wa )          ; The thin gate of nonTG & SD related gate
  e14Da1 = geomAndNot( geomButting( geomOr( drc( tgate_wa sep < 0.28 ) ) gate keep >= 2 ) MARK_C )
  errorLayer( e14Da1 "4.14D.a1: Minimum Poly to Poly spacing (on diffusion region without contact in the spacing, Poly width <= 0.24um) is 0.28um." )

  e14Da2 = geomAndNot( geomButting( geomOr( drc( wgate_wa gate_w sep < 0.32 ) ) gate keep >= 2 ) MARK_C )
  errorLayer( e14Da2 "4.14D.a2: Minimum Poly to Poly spacing (on difffusion region without contact in the spacing, Poly width > 0.24um(either side)) is 0.32um." )

  e14Db1_1= drc( gate npsdwct sep == 0 edgea opposite )
  e14Db1_2 = geomOr( drc( e14Db1_1 0 < sep < 0.34 shielded ) )
  e14Db1 = geomAndNot( e14Db1_2 MARK_A )
  errorLayer( e14Db1 "4.14D.b1/b2: Gate Poly spacing over diffusion w/contact is 0.34um" )

;
; Note: Rules 4.14D.c1 and 4.14D.c2.1 were combined into a single
;       absolute minimum space check.
;
  e14Dc_1 = drc( expol sepNotch < 0.24 shielded ) 
  e14Dc = geomAndNot( geomAndNot( e14Dc_1 gate ) MARK_A )
  errorLayer( e14Dc "4.14D.c: Field Poly spacing is 0.24um" )

  bgfply = geomWidth( expol keep > 0.24)
  bgfplc = geomAndNot( bgfply geomEnclose( bgfply CONT ) )
  bgfpedg = drc( bgfplc expol enc == 0 edgea opposite )
  smfpedg = geomAndNot( expol bgfpedg )
  blfpedg = geomGetLength( bgfpedg ignore <= 1.0 )
  blfpvio1 = geomOr( drc( blfpedg 0 < sep < 0.28 ) )
  blfpvio2 = geomOr( drc( blfpedg smfpedg 0 < sep < 0.28 ) )
  e14Dc22 = geomAndNot( geomGetLength( geomOr( blfpvio1 blfpvio2 ) keep > 1 ) gate )
  errorLayer( e14Dc22 "4.14D.c2.2: Wide Long Field Poly (width > 0.24um, length > 1.00um) spacing is 0.28um" )

; Note: According to the document, rule 4.14G refers to the end cap.
;       A simple enclosure check may flag false errors because the
;       field poly could have a 45-degree bend whose outer edge could
;       be less than .22um from the diffusion edge (rule 4.14N allows
;       .20um).  Thus, the enclosure check is performed with the
;       "opposite" modifier.

  e14E = geomAndNot( geomOr( drc( PO1 DIFF enc < 0.22 oppositeA ) ) MARK_A )
  errorLayer( e14E "4.14E: Minimum Poly extension onto field region (end cap) is 0.22um" )

;  e14F = geomAndNot( geomOr( drc( PO1 DIFF sep < 0.10 with_perp ) ) MARK_A )
;  errorLayer( e14F "4.14F: Minimum Poly on field region to Diffusion spacing is 0.1um" )

  e14F = geomAndNot( drc( PO1 DIFF sep < 0.10 with_perp ) geomOr( MARK_A DP ) )
  errorLayer( e14F "4.14F: Minimum Poly on field region to Diffusion spacing is 0.1um" )

;
; Note: This version of 4.8G is consistent with Cadence Methodology
;       and also takes into account notches in Diffusion in third party
;       libraries.
;
  actcnrs =  geomGetCorner( geomAndNot( DIFF geomOr( geomOr( SPRAM BLSP1 ) DP1 ) )
                            manhattanOnly concave )
  acnrext_1 = geomStretchCorner( actcnrs 0.12 )
  acnrext = drc( acnrext_1 DIFF sep == 0 edgea opposite )
  
  e14G_1 = geomButting( expol geomAndNot( gate geomOr( geomOr( SRAM BLSP1 ) DP1 ) )
                       keep == 1 )
  e14G_2 = geomStraddle( e14G_1 CONT )
  e14G_3 = geomAndNot( e14G_1 e14G_2 )
  e14G = geomAndNot( geomAnd( acnrext e14G_3 ) BLSPLP )
  errorLayer( e14G "4.14G: Minimum end cap Poly to related Diffusion spacing is 0.12um" )

 gate_adj_e = geomGetEdge( geomGetAdjacentEdge( geomAndNot( DIFF PO1 ) gate ) coincident DIFF )
  field_edge = geomAndNot( geomAndNot( DIFF geomGetEdge( DIFF coincident gate ) ) gate_adj_e )
  e14H = geomAndNot( geomOr( drc( DIFF gate_w enc < 0.28 parallel )
                             drc( field_edge gate_w  enc < 0.28 ) ) MARK_A )
  errorLayer( e14H "4.14H: Minimum Poly gate to field edge spacing is 0.28um" )

  gtrect2 = geomGetRectangle( gate2 )
  gtnonr2 = geomAndNot( gate2 gtrect2 )
  p2ga45 = geomGetAngledEdge( gtnonr2 keep == 45 )
  e14Ia = drc( p2ga45 width < 0.20 )
  errorLayer( e14Ia "4.14I.a: 1.8V bent gate width >= 0.20um." )

  gtrect3 = geomGetRectangle( gate3 )
  gtnonr3 = geomAndNot( gate3 gtrect3 )
  p3ga45 = geomGetAngledEdge( gtnonr3 keep == 45 )
  e14Ib = drc( p3ga45 width < 0.38 )
  errorLayer( e14Ib "4.14I.b: Minimum Poly width for 45 degree bent gate is 0.38um" )

  non45 = geomGetNon45( gate fig )
  fortyFive = geomGetAngledEdge( gate keep == 45 fig )
  angledGate = geomOr( non45 fortyFive )
  orthGate = geomAndNot( gate angledGate )
  gate_90 = geomCat( non45 geomGetVertex( orthGate keep > 4 ) )
  e14J = geomAndNot( gate_90 MARK_A )
  errorLayer( e14J "4.14J: Poly 90 degree bent gate is not allowed." )

;
; Note: Rule 4.8K is implemented as a purely area-based rule (6400 sq.
;       micron) and NOT a width and length limitation.
;
;  mgate = drc( gate  area <= 6400 )
;  e14K = geomAndNot( geomSize( gate -0.005 downUp noClipAcute )  mgate )
;  errorLayer( e14K "4.14K: Maximum Poly overlap Diffusion area is 6400 um^2" )

; Note: For rules 4.8L/M (recommanded rules), checks for putting in as many
;       contacts as possible into a diffusion can not be implemented.

;  gtsep54 = drc( gate sep < 0.54 opposite parallel )
;  sdwct1 = geomEnclose( geomAndNot( allsd gate ) CONT ) ; s/d not gate  
;  gtsep54ct = geomAnd( gtsep54 sdwct1 )
;  gtsep54edg = drc( gtsep54ct gate sep == 0 edgea opposite )

;  e14L = geomGetLength( gtsep54edg keep > 0.74 )
;  errorLayer( e14L "4.14L: If Poly gate separation < 0.54um, maximum Poly length on Diffusion is 0.74um" )

;  gtenc49 = drc( DIFF PO1 enc < 0.49 opposite parallel edgeb )
;  e14M_1 = geomGetEdge( gtenc49 inside DIFF )
;  e14M = geomGetLength( e14M_1 keep > 2.00 )
;  errorLayer( e14M "4.14M: If Active overlap of Poly gate < 0.49um, maximum Poly length on Diffusion is 2.0um" )

; Note: For rule 4.14N, the check is implemented as a spacing between
;       field poly and related diffusion, where "related" is defined
;       as the diffusion edge where the poly straddles it to create
;       the gate region.  This means that ONLY the situation described
;       in the design rule document will be flagged.

  bent_fpoly = geomGetAngledEdge( expol 0 < keep < 90 )
  gate_diff_edge = geomGetEdge( DIFF inside PO1 )
  bent_fp_sep_vio = drc( bent_fpoly gate_diff_edge sep < 0.2 )
  bent_fp_enc_vio = drc( bent_fpoly gate_diff_edge enc < 0.2 )
  e14N = geomAndNot( geomOr( bent_fp_sep_vio bent_fp_enc_vio )
		geomOr( SPRAM BLSP1 BLSPLP ) )
  errorLayer( e14N "4.14N: Minimum Poly bent gate on field region to Diffusion spacing is 0.2um" )

;
;******** HR RULE **************
;

  sab_dif       = geomButtOrOver( DIFF SAB )
  io_sd         = geomButtOrOver( sab_dif gate )
  io_sab        = geomButtOrOver( SAB io_sd )
  res_sab       = geomAndNot( SAB io_sab )
  sab_dif_res   = geomAndNot( sab_dif geomOverlap( sab_dif gate ) ) 
  asab_pol      = geomButtOrOver( expol res_sab ) ; PO1 for resistor
  sab_pol       = geomAvoiding( asab_pol HR )     ; NON-HR SAB poly resistor
  hsab_pol      = geomButtOrOver( asab_pol HR )   ; HR SAB poly resistor
  p_sab_pol     = geomOverlap( sab_pol PPLUS )
  n_sab_pol     = geomOverlap( sab_pol NPLUS )

  e15A = geomOr( drc( HR width < 0.6 )
	  	 drc( HR width < 0.01 withCornerTouch fig ) )
  errorLayer( e15A "4.15A: Minimum HR width is 0.6um" )

  e15B = drc( HR sepNotch < 0.6 ) 
  errorLayer( e15B "4.15B: Minimum HR to HR spacing is 0.6um" )

  hrpo = geomAnd( HR PO1 )
  e15C = drc( hrpo width  < 0.18 )
  errorLayer( e15C "4.15C: Minimum HR Poly width is 0.18um" )

  hrpo_sabedge = geomGetEdge( hrpo over SAB )
  e15D = geomGetLength( hrpo_sabedge keep < 1.0 )
  errorLayer( e15D "4.15D: Minimum SAB width for HR Poly resistor (Defome HR Poly resistor length) is 1.0um" )

; Note: The check for rule 4.15E was implemented such that it will
;       flag an error if HR straddles a poly piece.
  e15E = drc( HR hrpo enc < 1.5 )
  errorLayer( e15E "4.15E: Minimum HR mask overlap HR Poly resistor is 1.5um" )
  
  purpo = geomAndNot( PO1 hrpo )
  e15F = geomOr( drc( HR purpo sep < 2.0 ) )
  errorLayer( e15F "4.15F: Minimum HR to unrelated Poly spacing is 2.0um" )

  e15G = geomOr( drc( hrpo NPLUS sep < 0.5 with_perp ) )
  errorLayer( e15G "4.15G: Minimum N+imp layer to HR Poly spacing is 0.5um" )
  
  e15H = geomOr( drc( HR geomOutside( PPLUS HR ) sep < 0.5 with_perp ) )
  errorLayer( e15H "4.15H: Minimum P+imp layer to HR Poly spacing is 0.5um" ) 

  e15I1 = geomOr( drc( SAB hrpo enc < 0.5 ) )
  e15I2 = geomXor( SAB geomOverlap( hrpo SAB) )
  e15I3 = geomEnclose( geomOverlap( hrpo SAB) e15I2 ignore >= 2 )
  e15I4 = geomOverlap( SAB e15I3 )
  e15I  = geomOr( e15I1 e15I4 )
  errorLayer( e15I "4.15I: Minimum SAB extension over HR Poly is 0.5um" )

  hrpo_cont = geomAnd( hrpo CONT )
  e15J = drc( hrpo_cont SAB sep < 0.5 )
  errorLayer( e15J "4.15J: Minimum HR Poly contact to SAB spacing is 0.5um" ) 

  e15K = drc( HR DIFF sep < 0.5 )
  errorLayer( e15K "4.15K: Minimum HR to unrelated diffusion spacing is 0.5um" ) 

  e15L = drc( nwell hrpo enc < 2.0 )
  errorLayer( e15L "4.15L: Minimum NWELL layer overlap HR Poly is 2.0um" )

  e15M = geomAndNot( hrpo nwell )
  errorLayer( e15M "4.15M: HR Poly resistor must be allocated inside N-Well." )

  e15N_1 = geomOr( drc( PPLUS geomAnd( SAB HR ) ovlp == 0.2 ) )
  e15N = geomAvoiding( geomAnd( PPLUS geomAnd( SAB HR ) ) e15N_1 )
  errorLayer( e15N "4.15N: P+ implant overlap SAB is 0.2um" )

; The following is checked in SAB section since sabpolyres is not
; defined until then.
;
  e15O = geomOr( drc( PPLUS hsab_pol sep < 0.4 ) )
  errorLayer( e15O "4.15O: Minimum P+ implant spacing to unrelated poly resistor is 0.4um" )

;  e15P = geomOr( drc( hrpo PPLUS enc < 0.3 ) )
  e15P = geomOr( drc( PPLUS hrpo enc < 0.3 ) )
  errorLayer( e15P "4.15P: Minimum P+ implant layer overlap HR poly is 0.3um (this is the same for non-salicide poly resistor)" )

;
; ****** N+ IMPLANT RULE ******
;

  errorLayer( geomAndNot( DIFF geomOr( PPLUS NPLUS ) )
    "Warning : Active without N+ or P+ implant overlap was found" )

  e16A = geomAndNot( geomOr( drc( NPLUS width < 0.40 )
	   	 drc( NPLUS width < 0.01 withCornerTouch fig ) )
                 BLSPLP )
  errorLayer( e16A "4.16A: Minimum N+ implant width is 0.40um." )

  e16B = geomAndNot( drc( NPLUS sepNotch < 0.40 ) 
                     BLSPLP )
  errorLayer( e16B "4.16B: Minimum N+ implant spacing is 0.40um." )

;  e16Ca = geomAndNot( geomOr( drc( NPLUS actpsub enc < 0.22 )
;	      		      drc( NPLUS acttw enc < 0.22 ) ) MARK_E )
  e16Ca1 = geomAndNot( geomOr( drc( NPLUS actpsub enc < 0.22 with_perp )
	      		      drc( NPLUS acttw enc < 0.22 with_perp ) ) 
                       geomOr( BLSP DP BLSP1 BLSPLP ) )
  e16Ca  = geomAvoiding( e16Ca1 PPLUS ) ; exclude N+/P+ butting cases
  errorLayer( e16Ca "4.16C.a: Minimum N+ implant overlap N+ Diffusion (inside P-Well or Twell) is 0.22um" )

  
;  e16Cb = geomAndNot( geomOr( drc( NPLUS actnwel enc < 0.08 ) ) DP )
  
  e16Cb1 = drc( NPLUS geomAndNot( actnwel DP ) enc < 0.08 with_perp )
  e16Cb  = geomAvoiding( e16Cb1 PPLUS )
  errorLayer( e16Cb "4.16C.b: Minimum N+ implant overlap N+ Diffusion (inside N-Well) is 0.08um" )

;  e16Da_1 = geomOr( drc( NPLUS actnwel sep < 0.22 ) )
;  e16Da = geomButting( e16Da_1 pactnwel )
  e16Da_1 = geomOverlap( actnwel NPLUS )
  e16Da_2 = geomAndNot( actnwel e16Da_1 )  
  e16Da = geomOr( drc( NPLUS e16Da_2 sep < 0.22 with_perp ) )
  errorLayer( e16Da "4.16D.a: Minimum N+ implant to P+ Diffusion (inside N-Well) spacing is 0.22um" )

;  e16Db_1 = geomAndNot( geomOr( drc( NPLUS actpsub sep < 0.08 )
;	  	   	       drc( NPLUS acttw sep < 0.08 ) ) DP )
;  e16Db = geomButting( e16Db_1 pactpsub )

  e16Db_1 = geomOverlap( geomOr( actpsub acttw ) NPLUS )
  e16Db_2 = geomAndNot( geomOr( actpsub acttw ) e16Db_1 )
  e16Db   = geomAndNot( geomOr( drc( NPLUS e16Db_2 sep < 0.08 with_perp ) ) DP )

  errorLayer( e16Db "4.16D.b: Minimum N+ implant to P+ Diffusion (inside P-Well or Twell) spacing is 0.08um" )
 
;
; ****** N+/P+ BUTTING RULE ******
;

  pngtbutt = geomButting( pgate ngate )
  badgate = geomOverlap( gate pngtbutt )
  errorLayer( badgate "4.17J/4.16J: Minimum N+/P+ implant extension over Poly to form N+/P+ S/D is 0.32um" )

  badact2 = geomAnd( DIFF geomAnd( NPLUS PPLUS ) )
  errorLayer( badact2 "4.16F/4.17F: Minimum N+ to P+ diffusion spacing in the same potential is 0um" )

;
; Note: Rules 4.16M and 4.17M - prohibiting soft contacts are checked
;       as part of rules 4.16F and 4.17F which indicate that the
;       butting diffusions must be at the same potential (electrically
;       connected).
;
  e16F = geomOr( drc( ndiff pdiff sep == 0 diffNet ) )
  errorLayer( e16F "4.16F,M/4.17F,M: Butting N+ to P+ Diffusions must be at the same potential (electrically connected)." )
  
  e16G = geomOr( drc( DIFF butt_pplus enc < 0.24 ) )
  errorLayer( e16G "4.16G/4.17H: Minimum N+ implant overlap Diffusion / Diffusion extension over P+ implant to form N+ region is 0.24um" )

  e16H = geomOr( drc( butt_pplus DIFF ovlp < 0.24 ) )
  errorLayer( e16H "4.17G/4.16H: Minimum P+ implant overlap Diffusion / Diffusion extension over N+ Implant to form P+ region is 0.24um" )

;  gtup32 = geomSizeAnd( gate DIFF 0.10 0.32 )
;  e16I = geomAnd( gtup32 nbtap )
;  e16I = geomOr( drc( PPLUS pgate enc < 0.32 ) )
  e16I = geomOr( drc( butt_pplus gate_w enc < 0.32 ) )
  errorLayer( e16I "4.16I/4.17J: Minimum N+ implant to Poly spacing / P+ implant extension over Poly to form P+ S/D region is 0.32um" )

;  e16J = geomAnd( gtup32 pbtap )

;  e16J = geomOr( drc( NPLUS ngate enc < 0.32 ) )
  e16J = geomOr( drc( butt_pplus gate_w sep < 0.32 ) )
  errorLayer( e16J "4.17I/4.16J: Minimum P+ implant to Poly spacing / N+ implant extension over Poly to form N+ S/D region is 0.32um" )

  e16K1 = geomOr( drc( NPLUS ctndiff enc < 0.12 with_perp ) )
  e16K = geomAndNot( e16K1  MARK_C )
  errorLayer( e16K "4.16K/4.17L: Minimum N+ implant overlap N+ contact / P+ implant to N+ contact spacing is 0.12um" )
; Note: Rule 4.16M checked by 4.17M 


  e16N = geomAndNot( geomAndNot( geomAndNot( geomOverlap( nsd PO1 ) NWEL ) geomSizeAndNot( ptap NWEL 20 20 ) )
                      geomOr( IO SRAM DP1 BLSP1 ROM DIOBLK ) )
  errorLayer( e16N "4.16N: Maximum N+ Diffusion to the nearest P+ pick-up spacing (inside P-Well or Twell) is 20um (I/O, RAM, ROM, capacitor and diode are excepted)" )

;
; ****** P+ IMPLANT RULE ******
;
; This rule also apply to Twell P+ implant
;
  e17A = geomAndNot( geomOr( drc( PPLUS width < 0.40 )
	  	 drc( PPLUS width < 0.01 withCornerTouch fig ) )
                 BLSPLP )
  errorLayer( e17A "4.17A: Minimum P+ implant width is 0.4um" )

  e17B = geomAndNot( drc( PPLUS sepNotch < 0.40 ) BLSPLP )
  errorLayer( e17B "4.17B: Minimum P+ implant spacing is 0.4um" )

  e17Ca1 = geomOr( drc( PPLUS actnwel enc < 0.22 with_perp ) )
  e17Ca  = geomAvoiding( e17Ca1 NPLUS )
  errorLayer( e17Ca "4.17C.a: Minimum P+ implant overlap P+ Diffusion (inside N-Well) is 0.22um" )

  e17Cb1 = geomAndNot( geomOr( drc( PPLUS actpsub enc < 0.08 with_perp )
	      		      drc( PPLUS acttw enc < 0.08 with_perp ) ) DP )
  e17Cb  = geomAvoiding( e17Cb1 NPLUS )	      		      	      		      
  errorLayer( e17Cb "4.17C.b: Minimum P+ implant overlap P+ Diffusion (inside P-Well or Twell) is 0.08um" )

;  e17Da_1 = geomOr( drc( PPLUS actpsub sep < 0.22 )
;	  	    drc( PPLUS acttw sep < 0.22 ) )
;  e17Da = geomAndNot( geomButting( e17Da_1 nactpsub ) BLDP )

  e17Da_1 = geomOverlap( geomOr( actpsub acttw ) PPLUS )
  e17Da_2 = geomAndNot( geomOr( actpsub acttw ) e17Da_1 )
  e17Da = geomAndNot( geomOr( drc( PPLUS e17Da_2 sep < 0.22 with_perp ) ) BLDP )
  errorLayer( e17Da "4.17D.a: Minimum P+ implant to N+ Diffusion (inside P-Well or Twell) spacing is 0.22um" )

  e17Db = drc( PPLUS actnt_logic sep < 0.08 with_perp  ) 
 ; e17Db = geomButting( e17Db_1 nactnwel )

;  e17Db_1 = geomOverlap( actnwel PPLUS )
;  e17Db_2 = geomAndNot( actnwel e17Db_1 )
;  e17Db = geomOr( drc( PPLUS e17Db_2 sep < 0.08 with_perp ) )
  errorLayer( e17Db "4.17D.b: Minimum P+ implant to N+ Diffusion (inside N-Well) spacing is 0.08um" )

;
; ****** P+/N+ BUTTING RULE ******
;
  ;e17K = geomOr( drc( PPLUS ctpdiff enc < 0.12 ) )
  ;e17K = geomOr( drc( butt_pplus ctdiff enc < 0.12 ) ) 
  e17K = geomOr( drc( butt_pplus ctdiff enc < 0.12 with_perp ) geomButtOrOver( ctpdiff ctndiff ) )
  errorLayer( e17K "4.16L/4.17K: Minimum P+ implant overlap P+ contact / Minimum N+ implant to P+ contact spacing is 0.12um" )

  e17M = geomCat( geomAndNot( but_ps geomEnclose( but_ps CONT ) )
                  geomAndNot( but_ns geomEnclose( but_ns CONT ) )
                  geomAndNot( nbtap geomEnclose( nbtap CONT ) )
                  geomAndNot( geomAndNot( pbtap geomEnclose( pbtap CONT ) ) DP ) )
  errorLayer( e17M "4.16M/17M: Soft Contacts are prohibited." )

  e17N = geomAndNot( geomAndNot( geomOverlap( psd PO1 ) geomSizeAnd( ntap  NWEL 5 20 ) )
                      geomOr( IO SRAM BLSPLP BLSP1 CSYMBOL DSYMBOL ROM DIOBLK ) )
  errorLayer( e17N "4.17N: Maximum P+ Diffusion to the nearest N+ pick-up spacing is 20um (I/O, RAM, ROM, capacitor and diode are excepted)" )

;
; ****** SAB RULE ******
; and Non-Salicided Resistor

  e18A = geomOr( drc( SAB width < 0.60 )
	  	 drc( SAB width < 0.01 withCornerTouch fig ) )
  errorLayer( e18A "4.18A: Minimum SAB width is 0.6um" )

  e18B = drc( SAB sepNotch < 0.60 ) 
  errorLayer( e18B "4.18B: Minimum SAB spacing is 0.6um" )

; Note: Rules 4.18.1 and 4.18.2 - SAB Device and Resistor Definitions
;       SAB layer is used for ESD protection (device), poly resistors
;       and diffusion resistors.  The following definitions are
;       implemented:
;       - SAB Devices - Defined when SAB overlaps diffusion (P-diff in
;         N-Well or N-Diff in P-Sub) that IS touching a gate.
;       - SAB Poly Resistors - Defined when SAB overlaps field poly
;         that is not touching gate poly within the same SAB.
;       - SAB Diffusion Resistors - Defined when SAB overlaps
;         diffusion that is NOT touching a gate.
;       The check also assumes that each SAB will be dedicated to a
;       single definition.

  mos_sd = geomButting( allsd gate )          ; MOS S/D
  sabesd = geomOverlap( SAB mos_sd )          ; ESD protection SAB
  sab_fp = geomAnd( SAB expol )               ; SAB/Field Poly
  sab_fponly = geomAvoiding( sab_fp gate )    ; SAB/FPoly (w/o gate)
  sabpolyres = geomAndNot( geomOverlap( SAB sab_fponly )
  	geomInside( geomOverlap( SAB sab_fponly ) HR ) ) ; Poly Resistor SAB
	  

; ****** SAB Rules for Device ******
;

  e18C = geomOr( drc( DIFF SAB enc < 0.3 ) )
  errorLayer( e18C "4.18C: Minimum distance of SAB edge to Diffusion edge is 0.3um" )
 
  e18D = geomOr( drc( SAB geomAndNot( PO1 geomOverlap( PO1 SAB ) ) sep < 0.3 with_perp ) )
  errorLayer( e18D "4.18D: Minimum SAB to Poly spacing is 0.3um" )
  
  e18E = geomOr( drc( SAB DIFF sep < 0.24 with_perp ) )
  errorLayer( e18E "4.18E: Minimum SAB to unrelated Diffusion spacing is 0.24um" )

  e18Fa = geomOr( drc( SAB geomAndNot( PO1 geomOverlap( PO1 SAB ) ) sep < 0.3 with_perp ) )
  errorLayer( e18Fa "4.18F.a: Minimum SAB to Diffusion Contact spacing is 0.3um" )
  e18Fb = geomAndNot( geomOr( drc( SAB ctfpol sep < 0.3 ) geomAnd( SAB ctfpol ) ) HR )
  errorLayer( e18Fb "4.18F.b: Minimum SAB to Poly Contact spacing is 0.3um" )
  
; ****** SAB Rules for Non-Salicide Resistor ******
;

  sab_dif       = geomButtOrOver( DIFF SAB )
  io_sd         = geomButtOrOver( sab_dif gate )
  io_sab        = geomButtOrOver( SAB io_sd )
  res_sab       = geomAndNot( SAB io_sab )
  sab_dif_res   = geomAndNot( sab_dif geomOverlap( sab_dif gate ) ) ; Diffusion Resistor SAB

  asab_pol      = geomButtOrOver( expol res_sab ) ; PO1 for resistor
  sab_pol       = geomAvoiding( asab_pol HR )  	  ; NON-HR SAB poly resistor
  hsab_pol      = geomButtOrOver( asab_pol HR )   ; HR SAB poly resistor
  p_sab_pol     = geomOverlap( sab_pol PPLUS )
  n_sab_pol     = geomOverlap( sab_pol NPLUS )

  e18G = geomOr( drc( res_sab sab_dif_res enc < 0.38 )
                 drc( res_sab  sab_dif_res enc < 0.01 fig ) )
  errorLayer( e18G "4.18G: Minimum SAB extension over Diffusion non-salicide resistor is 0.38um" )

  e18H = geomOr( drc( res_sab sab_pol enc < 0.38 )
                 drc( res_sab sab_pol enc < 0.01 fig ) )
  errorLayer( e18H "4.18H: Minimum SAB extension over Poly non-salicide resistor is 0.38um" )

  res_con = geomAnd( CONT geomCat( sab_dif_res sab_pol ) )
  e18I = geomOr( geomOr( drc( res_sab res_con sep < 0.38 )
                         drc( res_sab res_con sep < 0.01 fig ) )
                         geomButting( res_sab CONT ) )
  errorLayer( e18I "4.18I: Minimum SAB to salicide contact spacing is 0.38um (include 4.18F.b)" )
  e18J = geomOr( drc( PPLUS p_sab_pol enc < 0.30 with_perp ) geomAndNot( p_sab_pol PPLUS ) )
  errorLayer( e18J "4.18J: Minimum P+ implant layer overlap P+ Poly non-salicide resistor is 0.3um" )

  e18K = geomOr( drc( PPLUS n_sab_pol sep < 0.30 ) )
  errorLayer( e18K "4.18K: Minimum P+ implant layer to N+ Poly non-salicide resistor spacing is 0.3um" )

  e18L  = geomOr( geomAndNot( p_sab_pol nwell )
	  	  drc( nwell p_sab_pol enc < 0.30 ) )
  errorLayer( e18L "4.18L: P+ Poly non-salicide resistor must be allocated inside N-Well. Minimum N-Well overlap P+ Poly non-salicide resistor is 0.3um" )

  e18M  = geomOr( geomAnd( n_sab_pol nwell )
	  	  drc( nwell n_sab_pol sep < 0.30 ) )
  errorLayer( e18M "4.18M: N+ Poly non-salicide resistor must be allocated outside N-Well. Minimum N-Well to N+ Poly non-salicide resistor spacing is 0.3um" )

  e18N = geomOr( drc( NPLUS n_sab_pol enc < 0.30 ) geomAndNot( n_sab_pol NPLUS ) )
  errorLayer( e18N "4.18N: Minimum N+ implant layer overlap N+ Poly non-salicide resistor is 0.3um" )

  e18O = geomOr( drc( NPLUS p_sab_pol sep < 0.30 ) )
  errorLayer( e18O "4.18O: Minimum N+ implant layer to P+ Poly non-salicide resistor spacing is 0.3um" )

  e18P = geomAnd( CONT SAB )
  errorLayer( e18P "4.18P: Non-salicide contact for device or non-salicide resistor is not allowed." )

;
; ****** CONT RULE ******
;

  e19A = geomAndNot( geomContactCheck( CONT length == 0.24 width == 0.24 ignore )
                     MARK_C )
  errorLayer( e19A "4.19A: Maximum and Minimum Contact size is 0.24 X 0.24um^2" )

  e19B = geomAndNot( geomOr( drc( CONT sepNotch < 0.26 ) 
                             drc( CONT sepNotch < 0.01 fig ) )
                     MARK_C )
  errorLayer( e19B "4.19B: Minimum Contact spacing is 0.26um" )

  alldiff1 = geomCat( ndiff1 pdiff1 )
  ctdiff1 = geomAnd( ctdiff alldiff1 )
  e19Ca = geomAndNot( geomOr( drc( ctdiff1 gate2 sep < 0.15 ) geomAnd( CONT gate )  )
                      MARK_G )
  errorLayer( e19Ca "4.19C.a: Minimum Diffusion Contact to Poly spacing (1.8V device) is 0.15um" )

  ctdiff3 = geomAndNot( ctdiff ctdiff1 ) 
  e19Cb = geomOr( drc( ctdiff3 gate3 sep < 0.30 ) geomAnd( ctdiff3 gate3 ) )
  errorLayer( e19Cb "4.19C.b: Minimum Diffusion Contact to Poly spacing (3.3 device) is 0.3um" )

  e19D = geomAndNot( geomOr( drc( ctfpol DIFF sep < 0.18 ) )
                     geomOr( BDSP DP2 BLSPLP ) )
  errorLayer( e19D "4.19D: Minimum Poly Contact to Diffusion edge spacing is 0.18um" )

  e19E = geomAndNot( geomOr( geomOr( drc( PO1 ctfpol enc < 0.10 )
                                     drc( PO1 ctfpol enc < 0.01 fig ) )
                                     geomAndNot( ctfpol PO1 ) )
                     MARK_H )
  errorLayer( e19E "4.19E: Minimum Poly overlap Contact is 0.1um" )

  e19F = geomAndNot( geomOr( geomOr( drc( pact ctpdiff enc < 0.10 ) 
                                     drc( pact ctpdiff enc < 0.01 fig ) )
                                     geomAndNot( ctpdiff pact ) )
                     MARK_J )
  errorLayer( e19F "4.19F: P+ Diffusion overlap Contact is 0.1um" )

  e19G = geomAndNot( geomOr( geomOr( drc( nact ctndiff enc < 0.10 )
                                     drc( nact ctndiff enc < 0.01 fig ) )
                                     geomAndNot( ctndiff nact ) )
                     MARK_J )
  errorLayer( e19G "4.19G: N+ Diffusion overlap Contact is 0.1um" )


; 4.19H: Put the contacts in the diffusion region as many as possible to avoid current drop by diffusion resistance.

  e19I = geomAndNot( geomAnd( CONT gate ) MARK_G )
  errorLayer( e19I "4.19I: Poly contact on Diffusion is not allowed." )


;
; ****** METAL1 RULE ******
;
; Note: All metal spaces are checked to the smaller design rule.  For
;       the wide metal spacing check, any edge that is considered part
;       of a wide metal is checked for spacing violations to all other
;       metal edges.  This interpretation applies to all metal layers.


  e20A = geomAndNot( geomOr( drc( ME1 width < 0.24 )
	      		     drc( ME1 width < 0.01 withCornerTouch fig ) )
                      MARK_H )
  errorLayer( e20A "4.20A: Minimum Metal1 width is 0.24um" )

  e20B = geomAndNot( drc( ME1 sepNotch < 0.24 ) MARK_H )
  errorLayer( e20B "4.20B.a: Minimum Metal1 to Metal1 spacing (absolute minimum) is 0.24um" )

  bmet1 = geomWidth( ME1 keep >= 10 )
  bmet1_edge1 = geomGetEdge( bmet1 coincident ME1 )
  bmet1_edge2 = geomAnd( bmet1 ME1 )
  geomConnect(
  via( bmet1_edge2 bmet1 ME1 )
  )
  e20Bb_1 = drc( bmet1_edge1 ME1 sep < 0.28 opposite )
  e20Bb_2 = drc( bmet1 ME1 sep < 0.28 diffNet )
  e20Bb = geomOr( e20Bb_1 e20Bb_2 )
  errorLayer( e20Bb "4.20B.b: Minimum Metal1 to Metal1 spacing (for Metal1 width >= 10um) is 0.28um" )

; Note : "Maximum metal spacing check" had been moved and grouped at the end of this file. 
;  if( avSwitch( "check_max_metal_space" )
;    then
;      bulk_with_m1=geomButtOrOver( chip_ext ME1 keep>=2)
;      fat_met = geomSize(ME1 1)
;      fat_met_a = geomSize(fat_met 2)
;      fat_met1 = geomSize( fat_met_a 247)
;      m1_max_space_vio1=geomAndNot(bulk_with_m1 fat_met1 )
;      m1_max_space_vio_a = geomSize(m1_max_space_vio1 1) 
;      m1_max_space_vio = geomSize(m1_max_space_vio_a 249) 
;      errorLayer( m1_max_space_vio
;        "4.20C: Maximum Metal1 to Metal1 spacing is 500um" )
;    ) ; end if "check_max_metal_space"


  e20D1 = geomAndNot( geomAndNot( CONT ME1 )
                      MARK_C )
  errorLayer( e20D1 "4.20D.a/d: Minimum Metal1 overlap contact is 0um" )
 
  cont_ex = geomAndNot( CONT geomOr( geomOr( SRAM BLSP1 ) DP1 ) ) 
;  e20D2 = geomAndNot( drc( ME1 cont_ex venc( enc1<0 enc2<0.08 enc3<0 enc4<0.08 ) )
;                      MARK_I )
  e20D2 = drc( geomSize( drc( ME1 cont_ex enc < 0.08 oppositeB edgeb) 0.1 ) width < 0.005 withCornerTouch )
  e20D3 = geomAndNot( e20D2 MARK_I )
  errorLayer( e20D3 "4.20D.b/c/e: Minimum Metal1 must enclose the contact on two entire non-adjacent edges is 0.08um" )

  e20E = geomOr( drc( ME1 0 < area < 0.1764 ) )
  errorLayer( e20E "4.20E: Minimum Metal1 area is 0.1764 um^2" )

;
; Use switch to check M1 coverage over the entire chip 
;
  if( avSwitch( "check_density" )
    then
      e20F_1 = drc( ME1 coverage < 0.30 )
      e20F = geomGetCoverage( e20F_1 keep < 0.30 )
      errorLayer( e20F "4.20F: The Metal1 coverage must be larger than 30% of the entire chip area." )

      e20G_1 = drc( ME1 coverage < 0.25 windowSize = 1000 stepSize = 500 )
      e20G = geomGetCoverage( e20G_1 keep < 0.25 )
      errorLayer( e20G "4.20G: Minimum Metal1 coverage for every millimeter square area is 25%" )
    ) ; end if "check_density"

;
; ****** VIA1 RULE ******
;
  e21A = geomContactCheck( VI1 length == 0.28 width == 0.28 ignore )
  errorLayer( e21A "4.21A: Maximum and Minimum Mvia1 size is 0.28 X 0.28um^2" )

  e21B = geomOr( drc( VI1 sepNotch < 0.28 ) drc( VI1 sepNotch < 0.01 fig ))
  errorLayer( e21B "4.21B.a/b: Minimum Mvia1 to Mvia1 spacing is 0.28um" )

  e21Ca = geomAndNot( VI1 ME1 )
  errorLayer( e21Ca "4.21C.a: Minimum Metal1 overlap Mvia1 is 0um" )

  sbmet1 = geomAndNot( bmet1 geomSize( geomSize( geomAndNot( ME1 bmet1 ) -0.1 downUp ) 0.005 ) )
  v1_bmet1 = geomInside( VI1 sbmet1 )
  e21Cb = geomOr( drc( ME1 v1_bmet1 enc < 0.2 with_perp ) )
  errorLayer( e21Cb "4.21C.b: Minimum wide Metal1 (>= 10.00um) overlap Mvia1 is 0.2um" )

  VI1_e21Cc = geomAndNot( VI1 geomOr( BDSP BLSPLP ) )
  e21Cc = drc( geomSize( drc( ME1 VI1_e21Cc enc < 0.08 oppositeB edgeb) 0.1 ) width < 0.005 withCornerTouch ) 
  errorLayer( e21Cc "4.21C.c/d/e: Minimum Metal1 must enclose the Mvia1 on two entire non-adjacent edges is 0.08um" )
   
;
; ****** METAL2 RULE ******
;
  if( avSwitch( "metal2_is_top" )
    then
      mett = geomCat( ME2 )
      viat = geomCat( VI1 )
    else

      e22A = geomOr( drc( ME2 width < 0.28 )
	  	     drc( ME2 width < 0.01 withCornerTouch fig ) )
      errorLayer( e22A "4.22A: Minimum Metal2 width is 0.28um" )

      e22B = drc( ME2 sepNotch < 0.28 ) 
      errorLayer( e22B "4.22B: Minimum Metal2 to Metal2 spacing (absolute minimum) is 0.28um" )

      bmet2 = geomWidth( ME2 keep >= 10 )
      bmet2_edge1 = geomGetEdge( bmet2 coincident ME2 )
      bmet2_edge2 = geomAnd( bmet2 ME2 )
      geomConnect(
      via( bmet2_edge2 bmet2 ME2 )
      )
      e22Bb_1 = drc( bmet2_edge1 ME2 sep < 0.32 opposite )
      e22Bb_2 = drc( bmet2 ME2 sep < 0.32 diffNet )
      e22Bb = geomOr( e22Bb_1 e22Bb_2 )
      errorLayer( e22Bb "4.22B.b: Minimum Metal2 to Metal2 spacing (for Metal2 width >= 10um) is 0.32um" )

; Note : "Maximum metal spacing check" had been moved and grouped at the end of this file. 
;       if( avSwitch( "check_max_metal_space" )
;         then
;           bulk_with_m2=geomButtOrOver( chip_ext ME2 keep>=2)
;           fat_met = geomSize(ME2 1)
;           fat_met_a = geomSize(fat_met 2)
;           fat_met1 = geomSize( fat_met_a 247)
;           m2_max_space_vio1=geomAndNot(bulk_with_m2 fat_met1 )
;           m2_max_space_vio_a = geomSize(m2_max_space_vio1 1) 
;           m2_max_space_vio = geomSize(m2_max_space_vio_a 249) 
;           errorLayer( m2_max_space_vio
;             "4.22C: Maximum Metal2 to Metal2 spacing is 500um" )
;         ) ; end if "check_max_metal_space"

      e22D1 = geomAndNot( VI1 ME2 )
      errorLayer( e22D1 "4.22D.a/d: Minimum Metal2 overlap Mvia1 is 0um" )

;      e22D2 = drc( ME2 VI1 venc( enc1<0 enc2<0.08 enc3<0 enc4<0.08 ) )
      e22D2 = drc( geomSize( drc( ME2 VI1 enc < 0.08 oppositeB edgeb) 0.1 ) width < 0.005 withCornerTouch )
      
      errorLayer( e22D2 "4.22D.b/c/e: Minimum Metal2 must enclose the Mvia1 on two entire non-adjacent edges is 0.08um" )

      e22E = geomOr( drc( ME2 0 < area < 0.1936 ) )
      errorLayer( e22E "4.22E: Minimum Metal2 area is 0.1936 um^2" )

;
; Use switch to check M2 coverage over the entire chip 
;
      if( avSwitch( "check_density" )
        then
          e22F_1 = drc( ME2 coverage < 0.30 )
          e22F = geomGetCoverage( e22F_1 keep < 0.30 )
          errorLayer( e22F "4.22F: The Metal2 coverage must be larger than 30% of the entire chip area." )
	  
      	  e22G_1 = drc( ME2 coverage < 0.25 windowSize = 1000 stepSize = 500 )
      	  e22G = geomGetCoverage( e22G_1 keep < 0.25 )
      	  errorLayer( e22G "4.22G: Minimum Metal2 coverage for every millimeter square area is 25%" )
        ) ; end if "check_density"
;
; ****** VIA2 RULE ******
;

      e23A = geomContactCheck( VI2 length == 0.28 width == 0.28 ignore )
      errorLayer( e23A "4.23A: Maximum and Minimum Mvia2 size is 0.28 X 0.28um^2" )

;      e23B = geomOr( drc( VI2 sep < 0.28 ) )
      e23B = drc( VI2 sep < 0.28 with_perp ) 
      errorLayer( e23B "4.23B.a/b: Minimum Mvia2 to Mvia2 spacing is 0.28um" )

      e23Ca = geomAndNot( VI2 ME2 )
      errorLayer( e23Ca "4.23C.a: Minimum Metal2 overlap Mvia2 is 0um" )

      sbmet2 = geomAndNot( bmet2 geomSize( geomSize( geomAndNot( ME2 bmet2 ) -0.1 downUp ) 0.005 ) )
      v2_bmet2 = geomInside( VI2 sbmet2 )
;      e23Cb = geomOr( drc( ME2 v2_bmet2 enc < 0.2 ) )
      e23Cb = geomOr( drc( ME2 v2_bmet2 enc < 0.2 with_perp ) )
      errorLayer( e23Cb "4.23C.b: Minimum wide Metal2 (>= 10.00um) overlap Mvia2 is 0.20um" )

;      e23Cc = drc( ME2 VI2 venc( enc1<0 enc2<0.08 enc3<0 enc4<0.08 ) )
      e23Cc = drc( geomSize( drc( ME2 VI2 enc < 0.08 oppositeB edgeb) 0.1 ) width < 0.005 withCornerTouch )
      errorLayer( e23Cc "4.23C.c/d/e: Minimum Metal2 must enclose the Mvia2 on two entire non-adjacent edges is 0.08um" )
 
;
; ****** METAL3 RULE ******
;

      if( avSwitch( "metal3_is_top" )
        then
          mett = geomCat( ME3 )
          viat = geomCat( VI2 )
        else

          e24A = geomOr( drc( ME3 width < 0.28 )
	      		 drc( ME3 width < 0.01 withCornerTouch fig ) )
          errorLayer( e24A "4.24A: Minimum Metal3 width is 0.28um" )

          e24B = drc( ME3 sepNotch < 0.28 ) 
          errorLayer( e24B "4.24B: Minimum Metal3 to Metal3 spacing (absolute minimum) is 0.28um" )

          bmet3 = geomWidth( ME3 keep >= 10 )
          bmet3_edge1 = geomGetEdge( bmet3 coincident ME3 )
          bmet3_edge2 = geomAnd( bmet3 ME3 )
          geomConnect(
          via( bmet3_edge2 bmet3 ME3 )
          )
          e24Bb_1 = drc( bmet3_edge1 ME3 sep < 0.32 opposite )
          e24Bb_2 = drc( bmet3 ME3 sep < 0.32 diffNet )
          e24Bb = geomOr( e24Bb_1 e24Bb_2 )
          errorLayer( e24Bb "4.24B.b: Minimum Metal3 to Metal3 spacing (for Metal3 width >= 10um) is 0.32um" )

; Note : "Maximum metal spacing check" had been moved and grouped at the end of this file. 
;          if( avSwitch( "check_max_metal_space" )
;            then
;              bulk_with_m3=geomButtOrOver( chip_ext ME3 keep>=2)
;              fat_met = geomSize(ME3 1)
;              fat_met_a = geomSize(fat_met 2)
;              fat_met1 = geomSize( fat_met_a 247)
;              m3_max_space_vio1=geomAndNot(bulk_with_m3 fat_met1 )
;              m3_max_space_vio_a = geomSize(m3_max_space_vio1 1) 
;              m3_max_space_vio = geomSize(m3_max_space_vio_a 249) 
;              errorLayer( m3_max_space_vio
;                "4.24C: Maximum Metal3 to Metal3 spacing is 500um" )
;            ) ; end if "check_max_metal_space"


          e24D1 = geomAndNot( VI2 ME3 )
          errorLayer( e24D1 "4.24D.a/d: Minimum Metal3 overlap Mvia2 >= 0um" )

;          e24D2 = drc( ME3 VI2 venc( enc1<0 enc2<0.08 enc3<0 enc4<0.08 ) )
          e24D2 = drc( geomSize( drc( ME3 VI2 enc < 0.08 oppositeB edgeb) 0.1 ) width < 0.005 withCornerTouch )
          errorLayer( e24D2 "4.24D.b/c/e: Minimum Metal3 must enclose the Via2 on two entire non-adjacent edges is 0.08um" )

          e24E = geomOr( drc( ME3 0 < area < 0.1936 ) )
          errorLayer( e24E "4.24E: Minimum Metal3 area is 0.1936 um^2" )

;
; Use switch to check M3 coverage over the entire chip
;
          if( avSwitch( "check_density" )
            then
              e24F_1 = drc( ME3 coverage < 0.30 )
              e24F = geomGetCoverage( e24F_1 keep < 0.30 )
              errorLayer( e24F "4.24F: The Metal3 coverage must be larger than 30% of the entire chip area." )
	      
      	      e24G_1 = drc( ME3 coverage < 0.25 windowSize = 1000 stepSize = 500 )
      	      e24G = geomGetCoverage( e24G_1 keep < 0.25 )
      	      errorLayer( e24G "4.24G: Minimum Metal3 coverage for every millimeter square area is 25%" )
            ) ; end if "check_density"
 
;
; ****** VIA3 RULE ******
;

          e25A = geomContactCheck( VI3 length == 0.28 width == 0.28 ignore )
          errorLayer( e25A "4.25A: Maximum and Minimum Mvia3 size is 0.28 X 0.28um^2" )

;          e25B = geomOr( drc( VI3 sep < 0.28 ) )
          e25B =  drc( VI3 sep < 0.28 with_perp ) 
          errorLayer( e25B "4.25B.a/b: Minimum Mvia3 to Mvia3 spacing is 0.28um" )

          e25Ca = geomAndNot( VI3 ME3 )
          errorLayer( e25Ca "4.25C.a: Minimum Metal3 overlap Mvia3 is 0um" )

          sbmet3 = geomAndNot( bmet3 geomSize( geomSize( geomAndNot( ME3 bmet3 ) -0.1 downUp ) 0.005 ) )
          v3_bmet3 = geomInside( VI3 sbmet3 )
;          e25Cb = geomOr( drc( ME3 v3_bmet3 enc < 0.2 ) )
          e25Cb = geomOr( drc( ME3 v3_bmet3 enc < 0.2  with_perp  ) )
          errorLayer( e25Cb "4.25C.b: Minimum wide Metal3 (>= 10.00um) Overlap Mvia3 is 0.2um" )

       ;   e25Cc = drc( ME3 VI3 venc( enc1<0 enc2<0.08 enc3<0 enc4<0.08 ) )
          e25Cc = drc( geomSize( drc( ME3 VI3 enc < 0.08 oppositeB edgeb) 0.1 ) width < 0.005 withCornerTouch )
          errorLayer( e25Cc "4.25C.c/d/e: Minimum Metal3 must enclose the Via3 on two entire non-adjacent edges is 0.08um" )
 
;
; ****** METAL4 RULE ******
;
          if( avSwitch( "metal4_is_top" )
            then
              mett = geomCat( ME4 )
              viat = geomCat( VI3 )
            else

              e26A = geomOr( drc( ME4 width < 0.28 )
		  	     drc( ME4 width < 0.01 withCornerTouch fig ) )
              errorLayer( e26A "4.26A: Minimum Metal4 width is 0.28um" )

              e26B =  drc( ME4 sepNotch < 0.28 ) 
              errorLayer( e26B "4.26B: Minimum Metal4 to Metal4 spacing (absolute minimum) is 0.28um" )
 
              bmet4 = geomWidth( ME4 keep >= 10 )
              bmet4_edge1 = geomGetEdge( bmet4 coincident ME4 )
              bmet4_edge2 = geomAnd( bmet4 ME4 )
              geomConnect(
              via( bmet4_edge2 bmet4 ME4 )
              )
              e26Bb_1 = drc( bmet4_edge1 ME4 sep < 0.32 opposite )
              e26Bb_2 = drc( bmet4 ME4 sep < 0.32 diffNet )             
              e26Bb = geomOr( e26Bb_1 e26Bb_2 )
              errorLayer( e26Bb "4.26B.b: Minimum Metal4 to Metal4 spacing (for Metal4 width >= 10um) is 0.32um" )

; Note : "Maximum metal spacing check" had been moved and grouped at the end of this file. 
;              if( avSwitch( "check_max_metal_space" )
;                then
;                  bulk_with_m4=geomButtOrOver( chip_ext ME4 keep>=2)
;                  fat_met = geomSize(ME4 1)
;                  fat_met_a = geomSize(fat_met 2)
;                  fat_met1 = geomSize( fat_met_a 247)
;                  m4_max_space_vio1=geomAndNot(bulk_with_m4 fat_met1 )
;                  m4_max_space_vio_a = geomSize(m4_max_space_vio1 1) 
;                  m4_max_space_vio = geomSize(m4_max_space_vio_a 249) 
;                  errorLayer( m4_max_space_vio
;                    "4.26C: Maximum Metal4 to Metal4 spacing is 500um" )
;                ) ; end if "check_max_metal_space"           


              e26D1 = geomAndNot( VI3 ME4 )
              errorLayer( e26D1 "4.26D.a/d: Minimum Metal4 overlap Mvia3 is 0um" )

;              e26D2 = drc( ME4 VI3 venc( enc1<0 enc2<0.08 enc3<0 enc4<0.08 ) )
              e26D2 = drc( geomSize( drc( ME4 VI3 enc < 0.08 oppositeB edgeb) 0.1 ) width < 0.005 withCornerTouch )
              errorLayer( e26D2 "4.26D.b/c/e: Minimum Metal4 must enclose the Via3 on two entire non-adjacent edges is 0.08um" )

              e26E = geomOr( drc( ME4 0 < area < 0.1936 ) )
              errorLayer( e26E "4.26E: Minimum Metal4 area is 0.1936 um^2" )

;
; Use switch to check M4 coverage over the entire chip 
;
              if( avSwitch( "check_density" )
                then
                  e26F_1 = drc( ME4 coverage < 0.30 )
                  e26F = geomGetCoverage( e26F_1 keep < 0.30 )
                  errorLayer( e26F "4.26F: The Metal4 coverage must be larger than 30% of the entire chip area." )
	      
      	     	  e26G_1 = drc( ME4 coverage < 0.25 windowSize = 1000 stepSize = 500 )
      	      	  e26G = geomGetCoverage( e26G_1 keep < 0.25 )
      	      	  errorLayer( e26G "4.26G: Minimum Metal4 coverage for every millimeter square area is 25%" )
                ) ; end if "check_density"
 
;
; ****** VIA4 RULE ******
;

              e27A = geomContactCheck( VI4 length == 0.28 width == 0.28 ignore )
              errorLayer( e27A "4.27A: Maximum and Minimum Mvia4 size is 0.28 X 0.28um^2" )
;              e27B = geomOr( drc( VI4 sep < 0.28 ) )
              e27B = drc( VI4 sep < 0.28 with_perp ) 
              errorLayer( e27B "4.27B.a/b: Minimum Mvia4 to Mvia4 spacing is 0.28um" )

              e27Ca = geomAndNot( VI4 ME4 )
              errorLayer( e27Ca "4.27C.a: Minimum Metal4 overlap Mvia4 is 0um" )

              sbmet4 = geomAndNot( bmet4 geomSize( geomSize(  geomAndNot( ME4 bmet4 ) -0.1 downUp ) 0.005 ) )
              v4_bmet4 = geomInside( VI4 sbmet4 )
;              e27Cb = geomOr( drc( ME4 v4_bmet4 enc < 0.2 ) )
              e27Cb = geomOr( drc( ME4 v4_bmet4 enc < 0.2 with_perp ) )
              errorLayer( e27Cb "4.27C.b: Minimum wide Metal4 (>= 10um) Overlap Mvia4 is 0.2um" )

;              e27Cc = drc( ME4 VI4 venc( enc1<0 enc2<0.08 enc3<0 enc4<0.08 ) )
              e27Cc = drc( geomSize( drc( ME4 VI4 enc < 0.08 oppositeB edgeb) 0.1 ) width < 0.005 withCornerTouch )
              errorLayer( e27Cc "4.27C.c/d/e: Minimum Metal4 must enclose the Via4 on two entire non-adjacent edges is 0.08um" )
 
;
; ****** METAL5 RULE ******
;

              if( avSwitch( "metal5_is_top" )
                then
                  mett = geomCat( ME5 )
                  viat = geomCat( VI4 )
                else
                  mett = geomCat( ME6 )
                  viat = geomCat( VI5 )

                  e28A = geomOr( drc( ME5 width < 0.28 )
		      		 drc( ME5 width < 0.01 withCornerTouch fig ) )
                  errorLayer( e28A "4.28A: Minimum Metal5 width is 0.28um" )

                  e28B = drc( ME5 sepNotch < 0.28 ) 
                  errorLayer( e28B "4.28B: Minimum Metal5 to Metal5 spacing (absolute minimum) is 0.28um" )

                  bmet5 = geomWidth( ME5 keep >= 10 )
                  bmet5_edge1 = geomGetEdge( bmet5 coincident ME5 )
                  bmet5_edge2 = geomAnd( bmet5 ME5 )
                  geomConnect(
                  via( bmet5_edge2 bmet5 ME5 )
                  )
                  e28Bb_1 = drc( bmet5_edge1 ME5 sep < 0.32 opposite )
                  e28Bb_2 = drc( bmet5 ME5 sep < 0.32 diffNet )
                  e28Bb = geomOr( e28Bb_1 e28Bb_2 )
                  errorLayer( e28Bb "4.28B.b: Minimum Metal5 to Metal5 spacing (for Metal5 width >= 10um) is 0.32um" )

; Note : "Maximum metal spacing check" had been moved and grouped at the end of this file. 
;                  if( avSwitch( "check_max_metal_space" )
;                    then
;                      bulk_with_m5=geomButtOrOver( chip_ext ME5 keep>=2)
;                      fat_met = geomSize(ME5 1)
;                      fat_met_a = geomSize(fat_met 2)
;                      fat_met1 = geomSize( fat_met_a 247)
;                      m5_max_space_vio1=geomAndNot(bulk_with_m5 fat_met1 )
;                      m5_max_space_vio_a = geomSize(m5_max_space_vio1 1) 
;                      m5_max_space_vio = geomSize(m5_max_space_vio_a 249) 
;                      errorLayer( m5_max_space_vio
;                        "4.28C: Maximum Metal5 to Metal5 spacing is 500um" )
;                    ) ; end if "check_max_metal_space"


                  e28D1 = geomAndNot( VI4 ME5 )
                  errorLayer( e28D1 "4.28D.a/d: Minimum Metal5 overlap Mvia4 is 0um" )

;                  e28D2 = drc( ME5 VI4 venc( enc1<0 enc2<0.08 enc3<0 enc4<0.08 ) )
                  e28D2 = drc( geomSize( drc( ME5 VI4 enc < 0.08 oppositeB edgeb) 0.1 ) width < 0.005 withCornerTouch )
                  errorLayer( e28D2 "4.28D.b/c/e: Minimum Metal5 must enclose the Via4 on two entire non-adjacent edges is 0.08um" )

                  e28E = geomOr( drc( ME5 0 < area < 0.1936 ) )
                  errorLayer( e28E "4.28E: Minimum Metal5 area is 0.1936 um^2" )

;
; Use switch to check M5 coverage over the entire chip
;
                  if( avSwitch( "check_density" )
                    then
                      e28F_1 = drc( ME5 coverage < 0.30 )
                      e28F = geomGetCoverage( e28F_1 keep < 0.30 )
                      errorLayer( e28F "4.28F: The Metal5 coverage must be larger than 30% of the entire chip area." )
	      
      	       	      e28G_1 = drc( ME5 coverage < 0.25 windowSize = 1000 stepSize = 500 )
      	      	      e28G = geomGetCoverage( e28G_1 keep < 0.25 )
      	      	      errorLayer( e28G "4.28G: Minimum Metal5 coverage for every millimeter square area is 25%" )
                    ) ; end if "check_density"
 
;
; ****** VIA5 RULE ******
;

                  e30A = geomContactCheck( VI5 length == 0.28 width == 0.28 ignore )
                  errorLayer( e30A "4.30A: Maximum and Minimum Mvia5 size is 0.28 X 0.28um^2" )

;		  e30B = geomOr( drc( VI5 sep < 0.28 ) )
		  e30B = drc( VI5 sep < 0.28 with_perp ) 
                  errorLayer( e30B "4.30B.a/b: Minimum Mvia5 to Mvia5 spacing is 0.28um" )

                  e30Ca = geomAndNot( VI5 ME5 )
                  errorLayer( e30Ca "4.30C.a: Minimum Metal5 overlap MVia5 is 0um" )

                  sbmet5 = geomAndNot( bmet5 geomSize( geomSize(  geomAndNot( ME5 bmet5 ) -0.1 downUp ) 0.005 ) )
                  v5_bmet5 = geomInside( VI5 sbmet5 )
;                  e30Cb = drc( ME5 v5_bmet5 enc < 0.2 )
                  e30Cb = geomOr( drc( ME5 v5_bmet5 enc < 0.2 with_perp ) )
                  errorLayer( e30Cb "4.30C.b: Minimum wide Metal5 (>= 10um) Overlap MVia5 is 0.2um" )

                  e30Cc = drc( ME5 VI5 venc( enc1<0 enc2<0.08 enc3<0 enc4<0.08 ) )
                  errorLayer( e30Cc "4.30C.c/d/e: Minimum Metal5 must enclose the Via5 on two entire non-adjacent edges is 0.08um" )

                ) ;end if "metal5_is_top"
            ) ;end if "metal4_is_top"
        ) ;end if "metal3_is_top"
    ) ;end if "metal2_is_top"
;
;
; ********* MMC Layer *********
;
  if( avSwitch( "metal2_is_top" )
    then
      lsm = geomCat( ME1 )
      lmvia = geomCat( VI1 )
    else if( avSwitch( "metal3_is_top" )
      then
        lsm = geomCat( ME2 )
        lmvia = geomCat( VI2 )
      else if( avSwitch( "metal4_is_top" )
        then
          lsm = geomCat( ME3 )
          lmvia = geomCat( VI3 )
      else if( avSwitch( "metal5_is_top" )
        then
          lsm = geomCat( ME4 )
          lmvia = geomCat( VI4 )
        else
          lsm = geomCat( ME5 )
          lmvia = geomCat( VI5 )
        ) ; end if "metal5_is_top"
      ) ; end if "metal4_is_top"
    ) ; end if "metal3_is_top"
  ) ; end if "metal2_is_top"
   
  e29A = geomOr( drc( MMC width < 0.6 )
	  	 drc( MMC width < 0.01 withCornerTouch fig ) )
  errorLayer( e29A "4.29A: Minimum METAL_CAP width is 0.6um" )

  e29B = drc( MMC sepNotch < 0.55 ) 
  errorLayer( e29B "4.29B: Minimum METAL_CAP to METAL_CAP spacing is 0.55um" )

  e29C = geomOr( drc( lsm MMC enc < 0.5 with_perp ) geomAndNot( MMC lsm ) )
  errorLayer( e29C "4.29C: Minimum LSM overlap METAL_CAP Length is 0.5um" )

  mmc_nolsm = geomAndNot( MMC lsm )
  errorLayer( mmc_nolsm "4.29C: METAL_CAP layer must be within LSM area." )

  e29D = geomOr( drc( MMC lmvia enc < 0.5 with_perp ) )
  errorLayer( e29D "4.29D: Minimum METAL_CAP overlap LMvia Length is 0.5um" )

  lmvia_straddlemmc = geomStraddle( lmvia MMC )
  errorLayer( lmvia_straddlemmc "4.29D: METAL_CAP must overlap LMvia - straddle is not allowed." )

  e29E = geomOr( drc( lmvia MMC sep < 0.5 ) )
  errorLayer( e29E "4.29E: Minimum Unrelated LMvia to METAL_CAP spacing is 0.5um" )

  e29F = geomOr( drc( MMC area > 10000.0 ) )
  errorLayer( e29F "4.29F: Maximum METAL_CAP overlap LSM area = 100um*100um." )

  lsm  = geomButtOrOver( geomEnclose( ME5 MMC ) geomOr( ME1 MCAP ) )
;  met1_block_slot = geomAnd( ME1 M1SLMK )
;  met1_slot_temp = geomHoles( met1_block_slot )
;  met1_slot = geomInside( met1_slot_temp M1SLMK )
;  met1_slot_all = geomOr( met1_block_slot met1_slot )
;  me1s = geomButtOrOver( met1_slot_all geomEnclose( geomOr( ME1 MCAP ) lsm ) )

  e29G = drc( ME1 lsm enc < 10 )
  errorLayer( e29G "4.29G: The minimum overlap of M1 ground plate to LSM is 10um" )

  e29H_1 = geomButtOrOver( geomButtOrOver( lsm MMC ) MCAP )
  e29H   = drc( MCAP e29H_1 enc < 10 )
  errorLayer( e29H "4.29H: Minimum overlap of P-Well block layer (block P-Well implant) to LSM is 10um" )
 
  e29I_a = drc( MCAP DIFF sep < 1  with_perp )
  errorLayer( e29I_a "4.29I:Outside MCAP : Minimum spacing of diffusion to MCAP is 1um" )
  
  e29I_b = drc( MCAP geomOverlap( DIFF MCAP ) enc < 4 )
  errorLayer( e29I_b "4.29I_b: Inside MCAP : Minimum MCAP enclosure of DIFFUSION is 4um" )
  
  e29I_c = drc( geomAnd( DIFF MCAP ) e29H_1 sep  < 4 )
  errorLayer( e29I_c "4.29I_c: Inside MCAP :  Minimum spacing of DIFFUSION to LSM is 4um" )

  e29J = geomAnd( NWEL MCAP )
  errorLayer( e29J "4.29J: Minimum spacing of N_WELL to MCAP is 0um" )

  e29K = geomAnd( PO1 MCAP )
  errorLayer( e29K "4.29K: Minimum spacing of POLY1 to MCAP is 0um" )
  
  e29L = geomAnd( NPLUS MCAP )
  errorLayer( e29L "4.29L: Minimum spacing of N+ to MCAP is 0um" )
;
; ****** TOP METAL RULE ******
;

  if( !avSwitch( "top_metal_is_thick" )
    then

      e31A = geomOr( drc( mett width < 0.44 )
	  	     drc( mett width < 0.01 withCornerTouch fig ) )
      errorLayer( e31A "4.31A: Minimum Top Metal width is 0.44um" )

      e31B = drc( mett sepNotch < 0.44 ) 
      errorLayer( e31B "4.31B: Minimum Top Metal to Top Metal spacing (absolute minimum) is 0.44um" )

      bmett = geomWidth( mett keep >= 10 )
      bmett_edge1 = geomGetEdge( bmett coincident mett )
      bmett_edge2 = geomAnd( bmett mett )
      geomConnect(
      via( bmett_edge2 bmett mett )
      )
      e31Bb_1 = drc( bmett_edge1 mett sep < 0.6 opposite )
      e31Bb_2 = drc( bmett mett sep < 0.6 diffNet )
      e31Bb = geomOr( e31Bb_1 e31Bb_2 )
      errorLayer( e31Bb "4.31B.b: Minimum Top Metal to Top Metal spacing (for Top Metal width >= 10um) >= 0.6um" )

      e31C1 = geomAndNot( viat mett )
      errorLayer( e31C1 "4.31C.a/d: Minimum Top Metal overlap Top Via is 0um" )

      e31C2 = drc( mett viat venc( enc1<0 enc2<0.12 enc3<0 enc4<0.12 ) )
      errorLayer( e31C2 "4.31C.b/c/e: Minimum Top Metal must enclose the Top Via on two entire non-adjacent edges is 0.12um" )

      e31D = geomOr( drc( mett 0 < area < 0.4624 ) )
      errorLayer( e31D "4.31D: Minimum Top Metal area is 0.4624 um^2" )

    else

      e31A = geomOr( drc( mett width < 1.2 )
	      	     drc( mett width < 0.01 withCornerTouch fig ) )
      errorLayer( e31A "4.31A: Minimum Thick Top Metal width is 1.2um" )

      e31B = drc( mett sepNotch < 1.0 ) 
      errorLayer( e31B "4.31B: Minimum Thick Top Metal to Top Metal spacing (absolute minimum) is 1.0um" )

      bmett = geomWidth( mett keep >= 10.00 )
      bmett_edge = geomGetEdge( bmett coincident mett )
      smett_edge = geomAndNot( mett bmett_edge )
      bmett_spvio1 = drc( bmett_edge 0 < sep < 1.5 shielded )
      bmett_spvio2 = drc( bmett_edge smett_edge 0 < sep < 1.5 shielded )
      e31Bb = geomOr( bmett_spvio1 bmett_spvio2 )
      errorLayer( e31Bb "4.31B.b: Minimum Thick Top Metal to Top Metal spacing (for Top Metal width >= 10um) is 1.5um" )

      viatup4 = geomSize( viat 0.4 )
      e31C = geomAndNot( viatup4 mett )
      errorLayer( e31C "4.31C: Minimum Top Via must be enclosed by Thick Top Metal is 0.4um" )

      e31D = geomOr( drc( mett 0 < area < 9 ) )
      errorLayer( e31D "4.31D: Minimum Top Metal area is 9 um^2" )
    ) ; end if "top_metal_is_thick"
;
; Use switch to check TopMetal coverage over the entire chip
;
  if( avSwitch( "check_density" )
    then
      e31E_1 = drc( mett coverage < 0.30 )
      e31E = geomGetCoverage( e31E_1 keep < 0.30 )
      errorLayer( e31E "4.31E: The Top Metal coverage must be larger than 30% of the entire chip area." )
	      
      e31G_1 = drc( mett coverage < 0.25 windowSize = 1000 stepSize = 500 )
      e31G = geomGetCoverage( e31G_1 keep < 0.25 )
      errorLayer( e31G "4.31G: Minimum Top Metal coverage for every millimeter square area is 25%" )
    ) ; end if "check_density"


  ind_met = geomAnd( ME6 LSYMBOL )
  e31H_1 = drc( IND ind_met enc < 10 opposite edgea )
  e31H_2 = geomAndNot( e31H_1 geomGetEdge( IND inside ME6 ) )
  errorLayer( e31H_2 "4.31H: The minimum overlap of IND to inductor layer is 10um" )
  e31H_3 = geomOr( geomAndNot( ind_met IND )
	           geomAndNot( geomButtOrOver( geomAnd( ME6 IND ) LSYMBOL ) LSYMBOL ) )
  errorLayer( e31H_3 "4.31H: The minimum overlap of IND to inductor layer is 10um" )
 
;
; ****** PESD RULE ******
;
  e33A = geomOr( drc( PESD width < 0.60 )
	  	 drc( PESD width < 0.01 withCornerTouch fig ) )
  errorLayer( e33A "4.33A: Minimum PESD width is 0.6um" )
 
  e33B = drc( PESD sepNotch < 0.60 ) 
  errorLayer( e33B "4.33B: Minimum PESD spacing is 0.60um" )

;
; ****** Seal Ring Rule ******
;

  if( avSwitch( "SR" ) then

; Note: Due to lack of defining layer, seal ring is identified by very
;       large holes in pdiff.  To change the area filter size for seal
;       ring, enter new value in the pdiff area check below.

    SRdiffhole_1 = geomHoles( pdiff )
    SRdiffhole = drc( SRdiffhole_1 area > 10000 fig )
    SRdiff = geomButtOnly( pdiff SRdiffhole )
    SRcont = geomOverlap( CONT SRdiff )
    SRmet1 = geomOverlap( ME1 SRdiff )
    SRvia1 = geomOverlap( VI1 SRmet1 )
    SRmet2 = geomOverlap( ME2 SRmet1 )
    SRvia2 = geomOverlap( VI2 SRmet2 )
    SRmet3 = geomOverlap( ME3 SRmet2 )
    SRvia3 = geomOverlap( VI3 SRmet3 )
    SRmet4 = geomOverlap( ME4 SRmet3 )
    SRvia4 = geomOverlap( VI4 SRmet4 )
    SRmet5 = geomOverlap( ME5 SRmet4 )
    SRvia5 = geomOverlap( VI5 SRmet5 )
    SRmet6 = geomOverlap( ME6 SRmet5 )
;
; Note: The following set of code is used to filter out contacts and
;       vias that need to be checked for potential spacing violations.
;       This is implemented for performance improvements.
;
    SRcont_up2 = geomSize( SRcont 2.0 )
    SRvia1_up2 = geomSize( SRvia1 2.0 )
    SRvia2_up2 = geomSize( SRvia2 2.0 )
    SRvia3_up2 = geomSize( SRvia3 2.0 )
    SRvia4_up2 = geomSize( SRvia4 2.0 )
    SRvia5_up2 = geomSize( SRvia5 2.0 )

    SRcont_nearv1 = geomButtOrOver( SRcont SRvia1_up2 )
    SRvia1_nearct = geomButtOrOver( SRvia1 SRcont_up2 )
    SRvia1_nearv2 = geomButtOrOver( SRvia1 SRvia2_up2 )
    SRvia2_nearv1 = geomButtOrOver( SRvia2 SRvia1_up2 )
    SRvia2_nearv3 = geomButtOrOver( SRvia2 SRvia3_up2 )
    SRvia3_nearv2 = geomButtOrOver( SRvia3 SRvia2_up2 )
    SRvia3_nearv4 = geomButtOrOver( SRvia3 SRvia4_up2 )
    SRvia4_nearv3 = geomButtOrOver( SRvia4 SRvia3_up2 )
    SRvia4_nearv5 = geomButtOrOver( SRvia4 SRvia5_up2 )
    SRvia5_nearv4 = geomButtOrOver( SRvia5 SRvia4_up2 )

    drc( SRcont PAD sep < 6
      "SR-5.1A Minimum passivation overlap substrate contact is 6um" )
    drc( SRmet1 SRcont enc < 2
      "SR-5.1B Minimum Metal1 overlap substrate contact is 2um" )
    drc( SRdiff SRcont enc < 1
      "SR-5.1D Minimum Diffusion overlap substrate contact is 1um" )
    drc( SRcont_nearv1 SRvia1_nearct sep < 2
      "SR-5.1E Minimum Mvia1 to substrate contact spacing is 2um" )
    ; SR-5.1F covered in mvia1 rules
    drc( SRmet2 SRvia1 enc < 1
      "SR-5.1G Minimum Metal2 overlap Mvia1 is 1um" )
    drc( SRmet3 SRvia2 enc < 1
      "SR-5.1H Minimum metal3 overlap Mvia2 is 1um" )
    ; SR-5.1I covered by mvia2 rules
    drc( SRvia1_nearv2 SRvia2_nearv1 sep < 2
      "SR-5.1J Minimum Mvia1 to Mvia2 spacing is 2um" )
    ; SR-5.1K no scribe identification layer
    drc( SRvia2_nearv3 SRvia3_nearv2 sep < 2
      "SR-5.1L Minimum Mvia2 to Mvia3 spacing is 2um" )
    ; SR-5.1M covered by mvia3 rules
    drc( SRmet4 SRvia3 enc < 1
      "SR-5.1N Minimum Metal4 overlap Mvia3 is 1um" )
    drc( SRmet5 SRvia4 enc < 1
      "SR-5.1O Minimum Metal5 overlap Mvia4 is 1um" )
    drc( SRvia3_nearv4 SRvia4_nearv3 sep < 2
      "SR-5.1Q Minimum Mvia3 to Mvia4 spacing is 2um" )
    drc( SRmet6 SRvia5 enc < 1
      "SR-5.1R Minimum Metal6 overlap Mvia5 is 1um" )
    ; SR-5.1S covered by mvia5 rules
    drc( SRvia4_nearv5 SRvia5_nearv4 sep < 2
      "SR-5.1T Minimum Mvia4 to Mvia5 spacing is 2um" )
    SRall1 = geomCat( SRdiff SRmet1 SRmet2 SRmet3 SRmet4 SRmet5 SRmet6 )
    SRall = geomOr( SRall1 )
    drc( SRall width < 10 "SR5.1.U Minimum Die seal ring width is 10um" )
    foreach( (metlayer ) '(ME1 ME2 ME3 ME4 ME5 ME6) 
      pad_metal = geomOverlap( eval(metlayer) PAD )
      drc( pad_metal SRall sep < 10
        "SR-5.1V Minimum PAD metal edge to die seal ring spacing is 10um" )
    )
    sr51w = geomWidth( SRdiff keep > 20 )
    errorLayer( sr51w "SR-5.1W Maximum seal ring diffusion width is 20um" )
    ; SR-5.1X no way to detect cont/via ditch without using cont/via bar

  ) ; end "SR"
;
; ****** 6.  Metal Stress Relief Rule ******
; ****** 6.1 Metal Slot Rule ******
;
  if( avSwitch( "check_slots" ) then

; Note: The slot rules do NOT apply to the Pad Metal and Pad Metal is
;       defined as metal overlapped by PAD window.

; Note: For Rule 6.2, the corner of the die is defined as the extent
;       of the chip area sized out by one resolution unit (0.005um) on
;       all 4 sides of the chip.


    foreach((metlay metslmk mettext) '(ME1 ME2 ME3 ME4 ME5 ME6)
				     '(M1SLMK M2SLMK M3SLMK M4SLMK M5SLMK M6SLMK)
                                     '(M1 M2 M3 M4 M5 M6)

      ; identify metal requiring slot
      bmmc = geomSize( MMC 10 )
      wide_metal_1 = geomAndNot( geomAndNot( eval(metlay)  bmmc ) PAD )
      wide_metal_2 = geomCoincident( wide_metal_1 eval(metlay) )
      wide_metal = geomGetLength( wide_metal_2 keep > 30 fig )
   
      ; get slot metal
      slotmetal_block = geomAnd( eval(metlay) eval(metslmk) )
      slotmetal_temp = geomHoles( slotmetal_block )
      slotmetal = geomInside( slotmetal_temp eval(metslmk) )
      slotmetal_all = geomOr( slotmetal_block slotmetal )

      ; get the slots
      holes_in_m = geomHoles( slotmetal )
      ; begin DRC checks

      ; 6.1.1A no slots
      bad_wide_m = geomSize( wide_metal -10.005 downUp clipAcute )
      evalstring( sprintf( nil "errorLayer( bad_wide_m
        \"6.1A Maximum Metal width without slotting is 20um for %L when length is greater than 30um, except bounding pad areas\" )" mettext ) )

      slot_wlt2 = geomOr( drc( slotmetal width < 2.0 )
	  		  drc( slotmetal width < 0.01 withCornerTouch fig ) )
      evalstring( sprintf( nil "errorLayer( slot_wlt2 
        \"6.1Ba Minimum slot width for %L is 2um\" )" mettext ) )

      slot_wlt5 = geomOr( drc( slotmetal width < 5.0 ) )
      slot_wgt5 = geomAndNot( slotmetal slot_wlt5 )
      
      evalstring( sprintf( nil "errorLayer( slot_wgt5 
        \"6.1Bb Maximum slot width for %L is 5um\" )" mettext ) )

; Note: For slot length check, the sides of the slots must be
;       measured.  Thus, the sides of the slots must first be defined.
;       This is done by defining the line ends as an end that contains
;       an "inBox" whose length and width are equal to the line end.
;       This definition also assumes that the slot width, and
;       therefore the line end, is less than 10um, the minimum slot
;       length.

      slot_ends = geomLineEnd( slotmetal 9.95 inBox( 1.0 1.0 relative ) )
      slot_sides = geomAndNot( slotmetal slot_ends )
      slot_llt10 = geomGetLength( slot_sides keep < 10 )
      evalstring( sprintf( nil "errorLayer( slot_llt10 
        \"6.1C.a Minimum slot length for %L is 10um\" )" mettext ) )

      slot_lgt250 = geomGetLength( slot_sides ignore <= 250 )
      evalstring( sprintf( nil "errorLayer( slot_lgt250 
        \"6.1C.b Maximum slot length for %L is 250um\" )" mettext ) )

;      slot_splt9 = drc( met_slot sepNotch < 9 )
      slot_splt9 = geomOr( drc( slotmetal sepNotch < 9 )
)
      evalstring( sprintf( nil "errorLayer( slot_splt9 
        \"6.1D.a Minimum slot spacing for %L is 9um\" )" mettext ) )

      slot_splt10 = geomAndNot( slotmetal geomSize( slotmetal -10.005 downUp ) )
      evalstring( sprintf( nil "errorLayer( slot_splt10
        \"6.1D.b Maximun slot spacing for %L is 20 um\" )" mettext ) )

       slot_enclt9 = geomOr( drc( slotmetal_all slotmetal enc < 9 ) )
       evalstring( sprintf( nil "errorLayer( slot_enclt9 
        \"6.1E.a Minimum slot to Metal edge spacing for %L is 9um\" )" mettext ) )

       ; 6.1.1E.b is check by 6.1D.b
    ) ; end foreach
  ) ; end "check_slots"

; New revision on 09/09/2003
; ****** 6.2 Die Corner Rule ******
  if( avSwitch( "check_die_corner" )
   then
    
    die_corner1 = geomGetCorner( geomBkgnd() manhattanOnly )
    die_cornerS400 = geomGrowCorner( die_corner1 400 inside )           ; 400um * 400um square
    die_cornerS410 = geomGrowCorner( die_corner1 410 inside )           ; 410um * 410um square
    die_cornerT300 = geomStretchCorner( die_corner1 424.2 convex )      ; triangle with edge length = 300 * 1.414

/*********   Original Coding for M1 *******************

    metc = geomAnd( ME1 die_cornerS410 )
    e62A_M1 = geomAnd( geomStretchCorner( geomGetCorner( metc ignore == 135 increment = 90 ) 0.1 ) die_cornerS400)
    errorLayer( e62A_M1 "6.2A_ME1: At die corners, M1 must make a 135-degree  turn." )

    e62B_M1 = geomAnd( ME1 die_cornerT300 )
    errorLayer( e62B_M1 "6.2B_ME1: Minimum M1 to die corner spacing is 300um." )

******************************************************/

/*********  Only for outLayer listing script ****************
    errorLayer( e62A_M2
    errorLayer( e62B_M2
    errorLayer( e62A_M3
    errorLayer( e62B_M3
    errorLayer( e62A_M4
    errorLayer( e62B_M4
    errorLayer( e62A_M5
    errorLayer( e62B_M5
    errorLayer( e62A_M6
    errorLayer( e62B_M6
*************************************************************/


    foreach((metlay mettext)    '(ME1 ME2 ME3 ME4 ME5 ME6)
                                '(M1 M2 M3 M4 M5 M6)

      metc = geomAnd( eval(metlay) die_cornerS410 )
      evalstring( sprintf( nil "e62A_%L = geomAnd( geomStretchCorner(
        geomGetCorner( metc ignore == 135 increment = 90 ) 0.1 ) die_cornerS400 )"
        mettext ) )
      evalstring( sprintf( nil "errorLayer( e62A_%L \"6.2A_%L: At die corners, %L must make a 135-degree turn.\" )"
        mettext metlay mettext ) )

      evalstring( sprintf( nil "e62B_%L = geomAnd( eval(metlay) die_cornerT300 )"
        mettext ) )
      evalstring( sprintf( nil "errorLayer( e62B_%L \"6.2B_%L: Minimum %L to die corner spacing is 300um.\" )"
        mettext metlay mettext ) )
  ) ; end foreach

); end if "check_die_corner"

;****** Meximum Metal Spaing Check ***********

if( avSwitch( "check_max_metal_space" )
    then
      bulk_with_m1=geomButtOrOver( chip_ext ME1 keep>=2)
      fat_met1 = geomSize(ME1 1)
      fat_met1_a = geomSize(fat_met1 2)
      fat_met1_247 = geomSize( fat_met1_a 247)
      m1_max_space_vio1=geomAndNot(bulk_with_m1 fat_met1_247 )
      m1_max_space_vio_a = geomSize(m1_max_space_vio1 1) 
      m1_max_space_vio = geomSize(m1_max_space_vio_a 249) 
      errorLayer( m1_max_space_vio
        "4.20C: Maximum Metal1 to Metal1 spacing is 500um" )
        
      bulk_with_m2=geomButtOrOver( chip_ext ME2 keep>=2)
      fat_met2 = geomSize(ME2 1)
      fat_met2_a = geomSize(fat_met2 2)
      fat_met2_247 = geomSize( fat_met2_a 247)
      m2_max_space_vio1=geomAndNot(bulk_with_m2 fat_met2_247 )
      m2_max_space_vio_a = geomSize(m2_max_space_vio1 1) 
      m2_max_space_vio = geomSize(m2_max_space_vio_a 249) 
      errorLayer( m2_max_space_vio
        "4.22C: Maximum Metal2 to Metal2 spacing is 500um" )
  
      
      bulk_with_m3=geomButtOrOver( chip_ext ME3 keep>=2)
      fat_met3 = geomSize(ME3 1)
      fat_met3_a = geomSize(fat_met3 2)
      fat_met3_247 = geomSize( fat_met3_a 247)
      m3_max_space_vio1=geomAndNot(bulk_with_m3 fat_met3_247 )
      m3_max_space_vio_a = geomSize(m3_max_space_vio1 1) 
      m3_max_space_vio = geomSize(m3_max_space_vio_a 249) 
      errorLayer( m3_max_space_vio
        "4.24C: Maximum Metal3 to Metal3 spacing is 500um" )
  
      
      bulk_with_m4=geomButtOrOver( chip_ext ME4 keep>=2)
      fat_met4 = geomSize(ME4 1)
      fat_met4_a = geomSize(fat_met4 2)
      fat_met4_247 = geomSize( fat_met4_a 247)
      m4_max_space_vio1=geomAndNot(bulk_with_m4 fat_met4_247 )
      m4_max_space_vio_a = geomSize(m4_max_space_vio1 1) 
      m4_max_space_vio = geomSize(m4_max_space_vio_a 249) 
      errorLayer( m4_max_space_vio
        "4.26C: Maximum Metal4 to Metal4 spacing is 500um" )
      
      bulk_with_m5=geomButtOrOver( chip_ext ME5 keep>=2)
      fat_met5 = geomSize(ME5 1)
      fat_met5_a = geomSize(fat_met5 2)
      fat_met5_247 = geomSize( fat_met5_a 247)
      m5_max_space_vio1=geomAndNot(bulk_with_m5 fat_met5_247 )
      m5_max_space_vio_a = geomSize(m5_max_space_vio1 1) 
      m5_max_space_vio = geomSize(m5_max_space_vio_a 249) 
      errorLayer( m5_max_space_vio
       "4.28C: Maximum Metal5 to Metal5 spacing is 500um" )
      
    ) ; end if "check_max_metal_space"

load( "/cad_area/Cadence/Cadence_PDK/UMC180/assura/ver9.1/G-DF-LOGIC18-1.8V-3.3V-1P6M-Assura-drc-memory.rul" )
; Above line is changed to full path on " Mon Mar 23 18:19:50 IST 2009" by Venky from Sankalp(contact : venky_p@sankalpsemi.com)
; This was done as assura was trying to find the rule file from invoke directory and failing to run
; Following is the error:
;	*Error* load: can't access file - "./G-DF-LOGIC18-1.8V-3.3V-1P6M-Assura-drc-memory.rul"
;	Errors exist in the rules file '/cad_area/Cadence/Cadence_PDK/UMC180/assura/ver9.1/drc.rul'.
;	*WARNING* Failed to build VDB. Cannot submit DRC Run.

; load( "./Assura/G-DF-LOGIC18-1.8V-3.3V-1P6M-Assura-drc-memory.rul" )


) ; drcExtractRules complete
